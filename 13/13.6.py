# Home Work
# 1 ==========================================================================
'''Задача 1. Урок информатики 2
В прошлый раз учитель написал программу, которая выводит числа в формате плавающей точки,
однако он вспомнил, что не учёл одну важную штуку: числа-то могут идти от нуля.
Задано положительное число x (x > 0). Ваша задача преобразовать его в формат плавающей
точки, то есть x = a • 10^b, где 1 ≤ a < 10. Обратите внимание, что x
теперь больше нуля, а не больше единицы. Обеспечьте контроль ввода.

Пример 1:
Введите число: 92345
Формат плавающей точки: x = 9.2345 * 10 ** 4

Пример 2:
Введите число: 0.0012
Формат плавающей точки: x = 1.2 * 10 ** -3
'''
# def floating_point_format(num):
#     a = num
#     b = 0
#     if a >= 10:
#         while num >= 10:
#             num /= 10
#             b += 1
#         print('Формат плавающей точки: ', a * 10 ** -b, '* 10 **', b)
#     elif a < 1 and a > 0:
#         while num < 1:
#             num *= 10
#             b += 1
#         print('Формат плавающей точки: ', a * 10 ** b, '* 10 **', str(-b))
#     elif a >= 1 and a < 10:
#         print('Формат плавающей точки: ', a * 10 ** b, '* 10 **', str(-b))
#     else:
#         print('Число должно быть неотрицательным и большим нуля!')

# x = float(input('Введите число положительное число > 0: '))
# floating_point_format(x)
# 2 ==========================================================================
'''Задача 2. Генеалогическое древо
Сэм создаёт генеалогические деревья разных семей. Ему постоянно приходится рассчитывать 
количество места, занимаемое именами родителей на экране.
Пользователь вводит имена и фамилии двух родителей. Создайте функцию 
get_parent_names_total_length для Сэма, которая возвращает количество символов в именах 
матери и отца суммарно, пробелы между именем и фамилией тоже учитываем.
Пример:
ФИ отца: Иван Петров
ФИ матери: Алена Петрова

Символов в ФИ отца: 11
Символов в ФИ матери: 13

Сумма символов: 24
'''
# def get_parent_names_total_length(father, mother):
#     count_f = 0
#     count_m = 0
#     for sym in father:
#         count_f += 1
#     print('Символов в ФИ отца: ', count_f)
#     for sym in mother:
#         count_m += 1
#     print('Символов в ФИ матери: ', count_m)
#     summ = count_f + count_m
#     return summ

# S_N_father = input('ФИ отца: ') # surname and name - фамилия и имя
# S_N_mother = input('ФИ матери: ') # surname and name - фамилия и имя

# S = get_parent_names_total_length(S_N_father, S_N_mother)
# print('Сумма символов: ', S)
# 3 ==========================================================================
'''Задача 3. Функция максимума
Юра пишет различные полезные функции для Питона, чтобы остальным программистам стало проще 
работать. Он захотел написать функцию, которая будет находить максимум из перечисленных чисел. 
Функция для нахождения максимума из двух чисел у него уже есть. Юра задумался: может быть, её 
можно как-то использовать для нахождения максимума уже от трёх чисел? Напишите программу, 
которая находит максимум из трёх чисел. Для этого используйте только функцию нахождения 
максимума из двух чисел.
'''
# def search_max(a, b):
#     maxx = round((a + b + abs(a - b)) / 2, 2)
#     return maxx

# num_1 = float(input('Введите первое число: '))
# num_2 = float(input('Введите второе число: '))
# num_3 = float(input('Введите третье число: '))

# maxx = search_max(num_1, num_2)
# maxx = search_max(maxx, num_3)

# print('Наибольшее число: ', maxx)
# 4 ==========================================================================
'''Задача 4. Число наоборот 2
Пользователь вводит два числа — N и K. Напишите программу, которая заменяет каждое число на 
число, которое получается из исходного записью его цифр в обратном порядке, затем складывает 
их, снова переворачивает и выводит ответ на экран.

Пример: 
Введите первое число: 102
Введите второе число: 123

Первое число наоборот: 201
Второе число наоборот: 321
Сумма: 522

Сумма наоборот: 225
'''
# def reverse(num):
#     new_num = ''
#     while num > 0:
#         new_num += str(num % 10)
#         num //= 10

#     return int(new_num)

# N = int(input('Введите первое число: '))
# K = int(input('Введите второе число: '))
# print()

# rev_N = reverse(N)
# rev_K = reverse(K)

# print('Первое число наоборот: ', rev_N)
# print('Второе число наоборот: ', rev_K)
# print()

# sum_NK = rev_N + rev_K

# print('Сумма: ', sum_NK)
# print()

# rev_NK = reverse(sum_NK)

# print('Сумма наоборот: ', rev_NK)
# 5 ==========================================================================
'''Задача 5. Урок информатики 3
Наконец-то учитель смог объяснить детям, что такое эта «плавающая точка». Однако долго его 
радость не продлилась, ведь на следующем уроке нужно будет объяснить такие страшные слова, 
как «экспоненциальное», «мантисса» и «порядок». Хоть старшеклассники и знакомы с экспонентой, 
учитель всё равно не уверен, что здесь всё будет понятно. Поэтому для наглядности он также 
написал программу.
На вход подаётся строка — это экспоненциальная форма числа. Напишите программу, которая 
выводит отдельно мантиссу и отдельно порядок этого числа.
'''
# flag = True
# M = ''
# P = ''

# exp_num = input('Введите число в экспоненциальной форме записи: ')

# for sym in exp_num:
#     if sym != 'e' and flag == True:
#         M += sym
#     elif sym == 'e':
#         flag = False
#     else:
#         P += sym

# print('Мантисса введенного числа: ', M)
# print('Порядок введенного числа: ', P)
# 6 ==========================================================================
'''Задача 6. Число Эйлера
Напишите программу, которая находит сумму нижеприведённого ряда с точностью до 1e-5.
e = ∑(от n=0 до ∞) 1/n! = (1/0!) + (1/1!) + (1/2!) + (1/3!) + ...
Пример:
Точность: 1e-20
Результат: 2.7182818284590455
'''
# import math

# precision = float(input('Точность: '))

# e = 0
# i = 0
# addMember = 1

# while addMember > precision:
#     addMember = 1/math.factorial(i)
#     e += addMember
#     i += 1

# print('Результат: ', e)
# print('Эталон: ', math.e)
# 7 ==========================================================================
'''Задача 7. Поехали по Марсу 
С вашей помощью учёные успешно высадили марсоход «Билли» на поверхность красной планеты, и 
вас назначили его оператором! Для правильного функционирования системы навигации был запущен 
GPS-спутник, измеряющий координаты марсохода. К сожалению, из-за непреодолимых трудностей 
работы в космосе спутник не удалось разместить ближе чем 0.001 а. е. (астрономических единиц) 
к поверхности планеты, тем не менее необходимо учитывать координаты марсохода относительно 
спутника с точностью до метра. 
Напишите программу для управления марсоходом наподобие той, которую вы делали раньше, только 
теперь начальные координаты X и Y марсохода равны 0.001 а. е. и 0 соответственно, а каждое 
нажатие W, S, A или D изменяет соответствующую координату на 1 метр (1 а. е. — единица 
измерения расстояния, приблизительно равна 1.496e + 11 метров).
Пример:
Марсоход на позиции  149600000.0 : 0 . Введите команду: w
Марсоход на позиции  149600000.0 : 1 . Введите команду: w
Марсоход на позиции  149600000.0 : 2 . Введите команду: s
Марсоход на позиции  149600000.0 : 1 . Введите команду: a
Марсоход на позиции  149599999.0 : 1 . Введите команду: a
Марсоход на позиции  149599998.0 : 1 . Введите команду:
'''
# x = 0.001 * 1.496e11
# y = 0
# while True:
#     move = input('Марсоход на позиции ' + str(x) + ', ' + str(y) + ' введите команду: ')
#     if move == 'a':
#         x -= 1
#     elif move == 'd':
#         x += 1
#     elif move == 'w':
#         y += 1
#     else:
#         y -= 1
#     if move == 'stop':
#         print('Наихралася бля!, завершение программы ...')
#         break
# 8 Недоделка 2 ==========================================================================
'''Задача 8. Недоделка 2
Вы всё так же работаете в конторе по разработке игр и смотрите различные программы прошлого 
горе-программиста. В одной из игр для детей, связанной с мультяшной работой с числами, вам 
нужно было написать код по следующим условиям: программа получает на вход два числа. В первом 
числе должно быть не меньше трёх цифр, во втором числе — не меньше четырёх, иначе программа 
выдаёт ошибку. Если всё нормально, то в каждом числе первая и последняя цифра меняются местами, 
а затем выводится их сумма.
И тут вы натыкаетесь на программу, которая была написана прошлым программистом и которая как 
раз решает такую задачу! Однако старший программист сказал вам немного переписать этот код, 
чтобы он не выглядел так ужасно. Да и вам самим становится, мягко говоря, не по себе от него. 
Разбейте приведённую ниже программу на функции. Повторений кода должно быть как можно меньше. 
Также сделайте, чтобы в основной части программы был только ввод чисел, затем изменённые числа 
и вывод их суммы.

first_n = int(input("Введите первое число: "))
first_num_count = 0
temp = first_n
while temp > 0:
    first_num_count += 1
    temp = temp // 10   
if first_num_count < 3:
 print("В первом числе меньше трёх цифр.")
else:
 last_digit = first_n % 10
 first_digit = first_n // 10 ** (first_num_count - 1)
 between_digits = first_n % 10 ** (first_num_count - 1) // 10
 first_n = last_digit * 10 ** (first_num_count - 1) + between_digits * 10 + first_digit
 print('Изменённое первое число:', first_n)
 second_n = int(input("\nВведите второе число: "))
 second_num_count = 0
 temp = second_n
 while temp > 0:
   second_num_count += 1
   temp = temp // 10   
 if second_num_count < 4:
   print("Во втором числе меньше четырёх цифр.")
 else:
   last_digit = second_n % 10
   first_digit = second_n // 10 ** (second_num_count - 1)
   betweenDigits = second_n % 10 ** (second_num_count - 1) // 10
   second_n = last_digit * 10 ** (second_num_count - 1) + between_digits * 10 + first_digit
   print('Изменённое второе число:', second_n)
   print('\nСумма чисел:', first_n + second_n)
'''
# def check_num(num_1, num_2):
#     count_1 = 0
#     count_2 = 0
#     temp_1 = num_1
#     temp_2 = num_2

#     while temp_1 > 0:
#         count_1 += 1
#         temp_1 = temp_1 // 10   
#     while temp_2 > 0:
#         count_2 += 1
#         temp_2 = temp_2 // 10   
    
#     if count_1 < 3:
#         print("В первом числе меньше 3 цифр.")
#         return 0
#     if count_2 < 4:
#         print("Во втором числе меньше 4 цифр.")
#         return 0

#     if count_1 >= 3 and count_2 >= 4:
#         last_digit = num_1 % 10                                                       # Последняя цифра
#         first_digit = num_1 // 10 ** (count_1 - 1)                                    # Первая цифра
#         between_digits = num_1 % 10 ** (count_1 - 1) // 10                            # Промежуточные цифры
#         num_1 = last_digit * 10 ** (count_1 - 1) + between_digits * 10 + first_digit  # Изменённое число
#         print('Изменённое первое число:', num_1)

#         last_digit = num_2 % 10                                                       # Последняя цифра
#         first_digit = num_2 // 10 ** (count_2 - 1)                                    # Первая цифра
#         between_digits = num_2 % 10 ** (count_2 - 1) // 10                            # Промежуточные цифры
#         num_2 = last_digit * 10 ** (count_2 - 1) + between_digits * 10 + first_digit  # Изменённое число
#         print('Изменённое первое число:', num_2)

#         summ = num_1 + num_2

#         return summ

# first_n = int(input("Введите первое число, в котором должно быть не меньше трёх цифр: "))
# second_n = int(input("Введите второе число, в котором должно быть не меньше четырех цифр: "))
# print()

# summ = check_num(first_n, second_n)
# if summ != 0:
#     print('\nСумма чисел:', summ)
# else:
#     print('\nОшибка! Одно из двух чисел не соответствуют формату ввода...')
# 9 Степень числа ==========================================================================
'''Задача 9. Степень числа
Дано вещественное положительное число a и целоe число n.
Вычислите a в степени n, не используя циклы, возведение в степень через ** и функцию math.pow() 
(да, такая тоже есть). Решение оформите в виде функции power(a, n).
'''
# Вар 1 - Это мой вариант решения, и он не совсем тот, как требовали решить
# def first_condition(a, n, c):
#     n -= 1
#     if n != 0:
#         a *= c
#         first_condition(a, n, c)
#     else:
#         print('Число A в степени B равно: ', a)

# def second_condition(a, n, c):
#     n -= 1
#     if n != 0:
#         a *= c
#         second_condition(a, n, c)
#     else:
#         print('Число A в степени B равно: ', 1/a)

# def power(a, n, c):
#     if n > 0:
#         first(a, n, c)
#     elif n == 0:
#         print('Число A в степени B равно: ', a)
#     else:
#         second(a, -n, c)

# a = float(input('Введите вещественное положительное число A: '))
# n = int(input('Введите целое число B: '))

# power(a, n, a)

# Вар 2
# def power(a, n):
#     if n == 0:
#         return 1
#     return a * power(a, n - 1)
 
# print('A**B = ', power(float(input('Число A: ')), int(input('Число B: '))))
# ===========================================
# def power(a, n):
#     if n == 0:
#         return 1
#     else:
#         return a * power(a, n - 1)

# a = float(input('Введите вещественное положительное число A: '))
# n = int(input('Введите целое число B: '))

# Pow = power(a, n)

# print('Число A в степени B равно: ', Pow)
# ===========================================
# def power_0(a, n):
#     if n == 0:
#         return 1

# def power_1(a, n):
#     return a * power_0(a, n - 1)

# def power_2(a, n):
#     return a * power_1(a, n - 1)

# def power_3(a, n):
#     return a * power_2(a, n - 1)

# a = 2
# n = 3
# Pow = power_3(a, n)

# print('Число A в степени n равно: ', Pow)
# print(f'Число {a} в степени {n} равно: ', Pow)
# ===========================================
# Ниже уже другая задача нахождения факториала также с помощью рекурсии, на ней тренировался и вникал
# def factorial(num):
#     if num == 1:
#         return 1
#     fact_n_minus_1 = factorial(num - 1)
#     return num * fact_n_minus_1

# num_fact = factorial(5)
# print(num_fact)

# ========================================
# def factorial_1(num):
#     if num == 1:
#         return 1

# def factorial_2(num):
#     return num * factorial_1(num - 1)

# def factorial_3(num):
#     return num * factorial_2(num - 1)

# num_fact = factorial_3(3)
# print(num_fact)
# 10 Маятник ==========================================================================
'''Задача 10. Маятник 
Известно, что амплитуда качающегося маятника с каждым разом затухает на 8,4% от амплитуды 
прошлого колебания. Если качнуть маятник, то, строго говоря, он не остановится никогда, 
просто амплитуда будет постоянно уменьшаться до тех пор, пока мы не сочтём такой маятник 
остановившимся. Напишите программу, определяющую, сколько раз качнётся маятник, прежде чем 
он, по нашему мнению, остановится. 
Программа получает на вход начальную амплитуду колебания в сантиметрах и конечную амплитуду 
его колебаний, которая считается остановкой маятника. Обеспечьте контроль ввода.
Пример:
Введите начальную амплитуду: 1
Введите амплитуду остановки: 0.1
Маятник считается остановившимся через 27 колебаний
'''
# def calculate(start_magnitude, stop_magnitude):
#     i = 0
#     while start_magnitude > stop_magnitude:
#         start_magnitude -= 0.084 * start_magnitude
#         i += 1
#     return i

# start_magnitude = int(input('Введите начальную амплитуду: '))
# stop_magnitude = float(input('Введите амплитуду остановки: '))
# print(calculate(start_magnitude, stop_magnitude))
# Решение с помощью рекурсии (есть ограничения на глубину рекурсии в 1000 итераций)=======================================
# def calculate(start_magnitude, stop_magnitude, i):
#     if start_magnitude < stop_magnitude:
#         return i
#     return calculate(start_magnitude - 0.084 * start_magnitude, stop_magnitude, i+1)

# i = 0
# start_magnitude = float(input('Введите начальную амплитуду: '))
# stop_magnitude = float(input('Введите амплитуду остановки: '))
# print(calculate(start_magnitude, stop_magnitude, i))
# 11 ==========================================================================
'''Задача 11. Яйца 
В рамках программы колонизации Марса компания «Спейс Инжиниринг» вывела особую породу черепах, 
которые, по задумке, должны размножаться, откладывая яйца в марсианском грунте. Откладывать 
яйца слишком близко к поверхности опасно из-за радиации, а слишком глубоко — из-за давления 
грунта и недостатка кислорода. Вообще, факторов очень много, но специалисты проделали большую 
работу и предположили, что уровень опасности для черепашьих яиц рассчитывается по формуле 
D = x^3 − 3x^2 − 12x + 10, где x — глубина кладки в метрах, а D — уровень опасности в условных 
единицах. Для тестирования гипотезы нужно взять пробу грунта на безопасной, согласно формуле,
глубине. 
Напишите программу, находящую такое значение глубины х, при котором уровень опасности как 
можно более близок к нулю. На вход программе подаётся максимально допустимое отклонение 
уровня опасности от нуля, а программа должна рассчитать приблизительное значение х, 
удовлетворяющее этому отклонению. Известно, что глубина точно больше нуля и меньше четырёх 
метров. Обеспечьте контроль ввода. 
Пример:
Введите максимально допустимый уровень опасности: 0.01
Приблизительная глубина безопасной кладки: 0.732421875 м
'''
# Вар 1 - мой способ решения, он оказался близок но не совсем верный
# print('='*60)
# h = 4
# count = 0

# # D = float(input('Введите максимально допустимый уровень опасности: '))
# max_level_of_danger = 0.01
# D = -1

# while abs(D - max_level_of_danger) >= 1e-5:
# # while abs(D) > max_level_of_danger:
#     count += 1
#     if D < 0: 
#         h = h - h / 2
#     else:
#         h = h + h / 2

#     D = h**3 - 3 * h**2 - 12 * h + 10

# print(f'new_D(h={h}) = {D} усл. ед.')
    
# print('Приблизительная глубина безопасной кладки: ', h)
# print('Кол-во итераций: ', count)
# ======================================================
# print('='*60)
# def calculation(current_D, max_danger, h, count):
#     eps = 1e-5
#     while abs(current_D - max_danger) >= eps:
#         count += 1
#         if current_D < 0: 
#             h = h - h / 2
#         else:
#             h = h + h / 2
#         current_D = h**3 - 3 * h**2 - 12 * h + 10
#     print('Кол-во итераций: ', count)
#     print(f'Уровень опасности на глубине {h} [метров] = {current_D} усл. ед.')
#     return h

# max_h = 4
# max_level_of_danger = float(input('Введите максимально допустимый уровень опасности: '))
# D = -1
# h = calculation(D, max_level_of_danger, max_h, 0)
# print('Приблизительная глубина безопасной кладки: ', h, 'метров.')
#=============================
# print('='*60)
# def calculation(current_D, max_danger, h):
#     count = 0
#     while abs(current_D) > max_danger:
#         count += 1

#         if current_D < 0: 
#             h = h - h / 2
#         else:
#             h = h + h / 2
#         current_D = h**3 - 3 * h**2 - 12 * h + 10
#     print(f'Уровень опасности на глубине {h} [метров] = {current_D} усл. ед.')
#     print('Кол-во итераций: ', count)
#     return h

# max_h = 4
# max_level_of_danger = float(input('Введите максимально допустимый уровень опасности: '))
# D = -1
# h = calculation(D, max_level_of_danger, max_h)
# print('Приблизительная глубина безопасной кладки: ', h, 'метров.')

# Вар 2 - это решение от Skillbox ================================================
print('='*60)
def calculation(max_danger):
    d_to = 0        # Значение d от нуля
    d_from = 4      # Значение d до четырех
    count = 0
    h = (d_to + d_from) / 2
    D = h**3 - 3 * h**2 - 12 * h + 10
    print('Глубина:', h,'[метров]\t\t||\t Уровень опасности:', D, '[усл. ед.]')
    while abs(D) > max_danger:
        count += 1
        if D < 0: 
            d_from = h
        else:
            d_to = h
        h = (d_to + d_from) / 2
        D = h**3 - 3 * h**2 - 12 * h + 10
        print('Глубина:', h,'[метров]\t\t||\t Уровень опасности:', D, '[усл. ед.]')
    print('`'*100,'\nКол-во итераций: ', count)
    return h

max_danger = float(input('Введите максимально допустимый уровень опасности: '))
if max_danger < 0:
    print('Максимально допустимый уровень опасности должен быть > 0!')
else:
    h = calculation(max_danger)
    print('Приблизительная глубина безопасной кладки: ', h, 'метров.')
print('='*50)
# 12 ==========================================================================
'''Задача 12. Сумма ряда
Пользователь вводит действительное число х и точность precision. Напишите программу, которая 
по число х вычисляет сумму ряда в точности до precision.
1 - (x^2/2!) + (x^4/4!) - (x^6/6!) + ... = ∑(от n=0 до ∞) (-1)^n * ((x^2*n)/(2*n)!)
Операцией возведения в степень и функцией factorial пользоваться нельзя.
Пример:
Введите точность: 0.001
Введите x: 5
Сумма ряда =  0.2836250150891709
'''
# def fact(n):
#     if n == 1:
#         return 1
#     return n * fact(n - 1)

# def power(a, n):
#     if n == 0:
#         return 1
#     return a * power(a, n - 1)

# precision = float(input('Введите точность: '))      # precision - точность
# x = float(input('Введите x: '))

# summ_of_series = 1                                  # summ_of_series - сумма ряда
# addMember = 1                                       # addMember - добавляемы член
# i = 2
# sign = 1                                            # sign - знак (числа)

# while abs(addMember) > precision:
#     sign *= -1
#     addMember = sign * power(x, i) / fact(i)
#     summ_of_series += addMember
#     i += 2

# print('Сумма ряда = ', summ_of_series)
# =====================================================
# def fact(n):
#     if n == 1 or n == 0:
#         return 1
#     return n * fact(n - 1)

# def power(a, n):
#     if n == 0:
#         return 1
#     return a * power(a, n - 1)

# def summ_series(precision, x):
#     summ_of_series = 0
#     addMember = 1
#     n = 0

#     while abs(addMember) > precision:
#         addMember = power(-1, n) * power(x, 2 * n) / fact(2 * n)
#         summ_of_series += addMember
#         n += 1

#     return summ_of_series

# precision = float(input('Введите точность: '))
# x = float(input('Введите x: '))

# print('Сумма ряда = ', summ_series(precision, x))
# 13 ==========================================================================
'''Задача 13. Аннуитетный платёж (по желанию)
Кредит в сумме S млн руб., выданный на n лет под i% годовых, подлежит погашению равными 
ежегодными выплатами в конце каждого года, включающими процентные платежи и сумму в погашение 
основного долга. Проценты начисляются один раз в год. После выплаты третьего платежа достигнута
договорённость между кредитором и заёмщиком о продлении срока погашения займа на n_2 лет и 
увеличении процентной ставки с момента конверсии до i_2%. Напишите программу, которая выводит 
план погашения оставшейся части долга.
Используйте следующие формулы (А — размер аннуитетного платежа, его дробную часть округлите 
до двух знаков, то есть до копеек): 
A = K * S
K = (i * (1 + i)^n)/(((1 + i)^n) - 1)
Пример:
Введите сумму кредита: 40e6
На сколько лет выдан? 5
Сколько процентов годовых? 6
Период: 1
Остаток долга на начало периода: 40 000 000.0
Выплачено процентов: 2 400 000.0
Выплачено тела кредита: 7 095 856.02
Период: 2
Остаток долга на начало периода: 32 904 143.98
Выплачено процентов: 1 974 248.6387999998
Выплачено тела кредита: 7 521 607.3812
Период: 3
Остаток долга на начало периода: 25 382 536.5988
Выплачено процентов: 1 522 952.195928
Выплачено тела кредита: 7 972 903.824072
Остаток долга: 17 409 632.774728
 ==================== 
На сколько лет продляется договор? 2
Увеличение ставки до: 10
Период: 1
Остаток долга на начало периода: 17 409 632.774728
Выплачено процентов: 1 740 963.2774728
Выплачено тела кредита: 3 751 267.5625271997
Период: 2
Остаток долга на начало периода: 13 658 365.2122008
Выплачено процентов: 1 365 836.52122008
Выплачено тела кредита: 4 126 394.3187799198
Период: 3
Остаток долга на начало периода: 9 531 970.89342088
Выплачено процентов: 953 197.0893420881
Выплачено тела кредита: 4 539 033.750657911
Период: 4
Остаток долга на начало периода: 4 992 937.142762969
Выплачено процентов: 499 293.71427629696
Выплачено тела кредита: 4 992 937.125723703
Остаток долга: 0.017039266414940357
'''
# print('='*60)
# def annuity_payment(S, i, n):
#     K = (i * (1 + i)**n) / ((1 + i)**n - 1)
#     A = round(K * S, 2)
#     return A

# def calculate(S, i, n, count):
#     percent_payment = S * i                                # percent_payment - выплата процентов
#     loan_body = annuity_payment(S, i, n) - percent_payment  # loan body - тело кредита

#     print('\nПериод', count)
#     print('Остаток долга на начало периода: ', S)
#     print('Выплачено процентов: ', percent_payment)
#     print('Выплаченая сумма в погашение основного долга: ', loan_body, end = '\n')
#     return loan_body

# S = float(input('Введите сумму кредита: '))
# n = int(input('На сколько лет выдан? '))
# i = int(input('Сколько процентов годовых? '))

# for count in range(1, 4):
#     loan_body = calculate(S, i/100, n, count)
#     S -= loan_body 
#     n -= 1
# else:
#     print('\nОстаток долга: ', S, '\n==================== ')
#     n_2 = int(input('На сколько лет продляется договор? '))
#     n += n_2
#     i = int(input('Увеличение ставки до: '))

#     for count in range(1, n + 1):
#         loan_body = calculate(S, i/100, n, count)
#         S -= loan_body
#         n -= 1

# print('Остаток долга: ', S)
