Операции с файлами и папками
Python решает задачи по работе с файлами с помощью функций из мо¬дуля os, но их можно решить и с помощью более нового модуля pathlib.
В ОС c иерархическими файловыми системами существует понятие текущего рабочего каталога (директории) (current working directory) — каталога файловой системы, используемого процессом в качестве начального при обращении к файлам c использованием относительных путей. 
Производите все манипуляции с файлами с осторожностью, придерживайтесь правила «семь раз отмерь — один раз отрежь». Не забывайте программно производить все возможные проверки перед выполнением операций.
Некоторая инфа, кот. можно получить с помощью методов файлового объекта
file = open('example_1.txt', 'w', encoding='utf=8')

data = 'Привет Python!\nРад тебя видеть!\n'
file_name = f'Имя файла: {file.name}'
file_close = f'Статус закрытия файла (True - закрыт): {file.closed}'
file_mode = f'Режим (mode) в котором был открыт файл: {file.mode}'
file_encoding = f'Кодировка файла: {file.encoding}'

data_list = [data, file_name, file_close, file_mode, file_encoding]
file.write('\n'.join(data_list))
file.close()
Результат (файл example_1.txt):
Привет Python!
Рад тебя видеть!

Имя файла: example_1.txt
Статус закрытия файла (True - закрыт): False
Режим (mode) в котором был открыт файл: w
Кодировка файла: utf=8
Модуль os
В большинстве ОС файлы существуют в рамках иерархии ката¬логов (иначе их еще называют папками). Контейнером для всех этих файлов и ката¬логов служит файловая система (иногда ее называют томом). Стандартный модуль os работает с такой иерархией и предоставляет функции, с помощью которых ею можно манипулировать. Модуль позволяет работать с файлами и папками. Русские названия файлов и папок возвращаются и принимаются всеми функциями этого модуля в кодировке UTF-8, поэтому, если это необходимо, можно использовать функции для перекодирования строк — методы decode и encode.
Важно знать, что модуль os используется не только для работы с файлами. Он включает массу методов и инструментов для других операций: обработки переменных среды, управления системными процессами, а также аргументы командной строки и даже расширенные атрибуты файлов, которые есть только в Linux. Тут будут рассмотрены основные, но далеко не все методы.
В любых методах описанных ниже, можно использовать '..' для работы с директорией выше или '/' для работы со внутренней.
Получение текущей рабочей директории 
Текущий рабочий каталог можно получить c помощью функции getcwd(). 
А функция getcwdb() модуля os вернет строку байтов, представляющую текущий рабочий каталог, причем она использует кодировку UTF-8 в Windows, а не кодовую страницу ANSI.
>>> import os
>>> print(os.getcwd())
C:\Users\HP\AppData\Local\Programs\Python\Python36-32
Изменение текущей рабочей директории
Для изменения текущего рабочего каталога используется метод chdir() модуля os.
>>> import os
>>> os.chdir("C:/Users/HP/Desktop/Code")
>>> print(os.getcwd())
C:\Users\HP\Desktop\Code
Полезные переменные, определенные в модуле os
import os

print('Метод os.pardir (переход к родительскому каталогу (т.е. на уровень выше)):',
                                                                         os.pardir)
print('Метод os.curdir (текущий рабочий каталог):', os.curdir)
print('Метод os.extsep (разделитель отделяющий имя файла от расширения):',
                                                                         os.extsep)
print('Метод os.sep (разделитель компонентов пути):', os.sep)
Результат:
Метод os.pardir (переход к родительскому каталогу (т.е. на уровень выше)): ..
Метод os.curdir (текущий каталог): .
Метод os.extsep (разделитель отделяющий имя файла от расширения): .
Метод os.sep (разделитель компонентов пути): \ или /
Получение информации об ОС
Чтобы узнать имя текущей ОС, достаточно воспользоваться методом name модуля os. В зависимости от установленной платформы (ОС), он вернет ее короткое наименование в строковом представлении. Доступные варианты: 'posix', 'nt', 'mac', 'os2', 'ce', 'java'. Следующий код был запущен на ПК с ОС Windows 10, поэтому результатом работы функции name является строка nt. Увидеть это можно при помощи обычного метода print.
import os
print(os.name)

Результат выполнения кода:
nt
Получить сведения, которые касаются конфигурации компьютера, можно при помощи метода environ модуля os. С его помощью пользователь получает большой словарь с переменными окружения, который выводится в консоль или строковую переменную. Таким образом, можно узнать название системного диска, адрес домашней директории, имя системы и массу другой информации. Следующий пример демонстрирует применение метода environ.
import os
print(os.environ)

Результат выполнения кода:
environ({'ALLUSERSPROFILE': 'C:\\ProgramData', …})
При помощи функции getenv() можно получить доступ к различным переменным среды. Чтобы сделать это, достаточно передать в качестве аргумента необходимое название переменной, как в следующем примере, который выводит на экран сведения о TMP на экран. А при помощи функции os.putenv() можно установить значение переменной окружения.
import os
print(os.getenv("TMP"))

Результат выполнения кода:
C:\Users\admin\AppData\Local\Temp

os.getenv('PATH')

Результат выполнения кода:
C:\\python\\Scripts\\;C:\\python\\;C:\\WINDOWS\\system32;C:\\WINDOWS
Информация о файлах и директориях
Получить основные сведения об объекте можно через функцию os.stat(). Передав ей в качестве параметра, расположение файла или папки на диске компьютера, она вернет небольшой массив информации (в следующем порядке: st_mode, st_ino, st_dev, st_nlink, st_uid, st_gid, st_size, st_atime, st_mtime, st_ctime). В ней можно найти данные о размере объекта в байтах, а также некие числовые значения, отображающие доступ и режим его работы.
import os

open("text.txt", "w").write("Это текстовый файл")

# вывести некоторые данные о файле
print(os.stat("text.txt"))

Результат выполнения кода:
os.stat_result(st_mode=33206, st_ino=14355223812608232, st_dev=1558443184, st_nlink=1, st_uid=0, st_gid=0, st_size=19, st_atime=1575967618, st_mtime=1575967618, st_ctime=1575966941)
Это вернет кортеж с отдельными метриками. В их числе есть следующие:
•	st_size — размер файла в байтах;
•	st_atime — время последнего доступа в секундах (временная метка);
•	st_mtime — время последнего изменения;
•	st_ctime — в Windows это время создания файла, а в Linux — последнего изменения метаданных.
Для получения конкретного атрибута нужно писать следующим образом:
# например, получить размер файла
print("Размер файла:", os.stat("text.txt").st_size)

Результат выполнения кода:
Размер файла: 19
Подробнее см. https://docs-python.ru/standart-library/modul-os-python/obekt-stat-result-modulja-os/ . Тут есть описание всех метрик.
Получение времени последней модификации файла или каталога
Функция os.getmtime(path) возвращает время последней модификации файла или каталога, указанного в path. Возвращаемое значение представляет собой число с плавающей запятой, указывающее количество секунд с начала эпохи Unix (для подробностей см. модуль time).
Если файл не существует или недоступен, то поднимается исключение OSError.
Функция time.ctime([secs]) преобразует время secs (float), выраженное в секундах с начала "эпохи", в строку вида: "Fri Apr 24 15:31:03 2020", представляющую местное время.
Поле с указанием дня имеет длину два символа и дополняется пробелом, если день представляет собой одну цифру.
Если значение secs не указано или отсутствует, используется текущее время, возвращаемое функцией time.time().
import os.path
import time

os.path.getmtime('/home/docs-python/os.path.txt')
# 1585212542.419274

# время последней модификации файла 
mtime = os.path.getmtime('/home/docs-python/os.path.txt')
time.ctime(mtime)
# 'Thu Mar 26 11:49:02 2020'

# время последней модификации каталога
mtime = os.path.getmtime('/home/docs-python')
time.ctime(mtime)
# 'Thu Mar 26 15:07:01 2020'


Проверить, является ли путь абсолютным.
Функция isabs(path) модуля os.path возвращает True если путь является абсолютным, False в противном случае. path - путь к файлу или каталогу.
Получить относительный путь к файлу из каталога.
Функция os.path.relpath(path, start=os.curdir) возвращает относительный путь к файлу path либо из текущего каталога, либо из необязательного начального каталога start. Эта функция производит только вычисление пути и не обращается к файловой системе для подтверждения существования пути path. Для аргумента start по умолчанию запускается функция os.curdir.
Рекурсивный обход папок с помощью функции walk()
Одной из самых интересных и мощных функций является функция os.walk().
Синтаксис: os.walk(top, topdown=True, onerror=None, followlinks=False)
Параметры:
•	top - str, вершина каталога,
•	topdown=True - bool, направление обхода,
•	onerror=None - функция, которая сообщает об ошибке,
•	followlinks=False - bool, переходить ли по символическим ссылкам.

Функция os.walk() позволяет рекурсивно пройтись по всем папкам, подпапкам, их подпапкам и так далее. На самом деле она возвращает генератор (последовательность элементов). Каждый элемент представляет собой тройной кортеж (кортеж из 3х элементов):
•	Первый элемент (dirpath) - строковое представление текущей директории, которую просматривает функция (это строка, путь к каталогу).
•	Второй элемент (dirnames) - список всех подпапок данной директории (это список имен подкаталогов в dirpath, исключая особые символы '.' и '..'). 
•	Третий элемент (filenames) - список всех файлов этой директории (это список имен файлов в dirpath (не-каталогов)).
Другими словами функция walk() модуля os генерирует имена файлов в дереве каталогов, обходя дерево сверху вниз или снизу вверх. Для каждого каталога в дереве с корнем в вершине каталога top, включая саму вершину top, она выдает тройной кортеж (dirpath, dirnames, filenames).
for current_dir, dirs, files in os.walk("."): # Передаем в качестве аргумента
                                    текущую директорию ("." - означает именно ее)
    print(current_dir, dirs, files)  # Выведем, что получается
Т.О. функция os.walk() возвращает объект-генератор. Это значит, что такие объекты можно итерировать в циклах. Из полученного объекта можно получить кортежи для каждого каталога в файловой иерархии. Каждый кортеж в коллекции содержит: (абсолютный адрес очередного каталога (строка), имена подкаталогов текущего каталога (список), имена (без адреса) файлов данного каталога)).
Функция os.walk() является рекурсивной. Это значит, что для поиска файлов в конкретной директории вы будете итерировать и все вложенные папки. Обойти это с помощью самого метода нельзя, но можно использовать break так как os.walk() возвращает указанную директорию первой. Можно так же использовать next():
import os

path = 'C:/Folder1'
for dirs,folder,files in os.walk(path):
    print('Выбранный каталог: ', dirs)
    print('Вложенные папки: ', folder)
    print('Файлы в папке: ', files)
    print('\n')
    # Отобразит только корневую папку и остановит цикл
    break

# Отобразит первый итерируемый объект
directory = os.walk(path)
print(next(directory))
Обратите внимание, что имена в списках не содержат компонентов пути. Чтобы получить полный путь, который начинается с top, к файлу или каталогу в dirpath, необходимо выполнить os.path.join(dirpath, name).
Т.О. воспользовавшись функцией os.walk(), можно получить доступ к названиям и путям всех подпапок и файлов, относящихся к заданному каталогу. Применив один внешний цикл for, а также два вложенных, несложно получить информацию об объектах в каталоге folder через списки directories и files, которые являются третьим элементом кортежа. Сведения выдаются с помощью многократного обращения к функции print(). 
Если необязательный аргумент topdown имеет значение True или не указан, тройной кортеж для каждой папки создается перед тройным кортежем для любой из ее подпапок, т. е. каталоги создаются сверху вниз. Если topdown имеет значение False, тройной кортеж для каталога создается после тройного кортежа для всех его подкаталогов, т. е. каталоги создаются снизу вверх. Независимо от значения topdown, список подкаталогов извлекается до создания кортежей для каталога и его подкаталогов. См. примеры ниже:
import os

os.chdir('for test_14')

path = os.path.abspath(os.path.curdir)

for dirpath, dirnames, filenames in os.walk(path):
    print('Текущая директория: ' + dirpath)
    # цикл по поддиректориям текущей директории
    for subdir in dirnames:
        print('\tДочерняя директория: ' + subdir)
    # цикл по файлам текущей директории
    for file in filenames:
        print('\tФайл в директории: ' + file)
Результат выполнения кода (если параметр topdown = True (по умолчанию)):
Текущая директория: D:\Works of Skillbox\1. Python Basic\22\for test_14
	Дочерняя директория: f_1
	Файл в директории: hello.py
	Файл в директории: hello.txt
Текущая директория: D:\Works of Skillbox\1. Python Basic\22\for test_14\f_1
	Дочерняя директория: f_3
	Дочерняя директория: f_5
	Файл в директории: 11.txt
	Файл в директории: 12.txt
Текущая директория: D:\Works of Skillbox\1. Python Basic\22\for test_14\f_1\f_3
	Файл в директории: 11.txt
	Файл в директории: 12.txt
Текущая директория: D:\Works of Skillbox\1. Python Basic\22\for test_14\f_1\f_5
	Дочерняя директория: f_6
Текущая директория: D:\Works of Skillbox\1. Python Basic\22\for test_14\f_1\f_5\f_6
	Дочерняя директория: f_7
Текущая директория: D:\Works of Skillbox\1. Python Basic\22\for test_14\f_1\f_5\f_6\f_7
	Файл в директории: 1.txt
Результат выполнения кода (если параметр topdown = False):
Текущая директория: D:\Works of Skillbox\1. Python Basic\22\for test_14\f_1\f_3
	Файл в директории: 11.txt
	Файл в директории: 12.txt
Текущая директория: D:\Works of Skillbox\1. Python Basic\22\for test_14\f_1\f_5\f_6\f_7
	Файл в директории: 1.txt
Текущая директория: D:\Works of Skillbox\1. Python Basic\22\for test_14\f_1\f_5\f_6
	Дочерняя директория: f_7
Текущая директория: D:\Works of Skillbox\1. Python Basic\22\for test_14\f_1\f_5
	Дочерняя директория: f_6
Текущая директория: D:\Works of Skillbox\1. Python Basic\22\for test_14\f_1
	Дочерняя директория: f_3
	Дочерняя директория: f_5
	Файл в директории: 11.txt
	Файл в директории: 12.txt
Текущая директория: D:\Works of Skillbox\1. Python Basic\22\for test_14
	Дочерняя директория: f_1
	Файл в директории: hello.py
	Файл в директории: hello.txt
Если пути top не существует, ошибки это не вызовет, просто ничего не будет выведено.
Когда topdown имеет значение True, вызывающий объект может изменить список dirnames на месте, используя например инструкцию del или срезы (slice) и функция os.walk() будет возвращаться только в подкаталоги, чьи имена остаются в dirnames. Такое поведение может быть использовано для сокращения поиска, наложения определенного порядка посещения или даже для информирования os.walk() о каталогах, которые вызывающий абонент создает или переименовывает, прежде чем возобновится генерация имен файлов в дереве каталогов. Изменение dirnames, когда topdown имеет значение False не влияет на поведение обхода, поскольку в режиме снизу вверх каталоги с именами dirname генерируются до того, как генерируется сам dirpath.
Подробнее см. https://docs-python.ru/standart-library/modul-os-python/funktsija-walk-modulja-os/.
Примечания:
•	Имейте в виду, что установка followlinks=True может привести к бесконечной рекурсии, если ссылка указывает на родительский каталог. Функция os.walk() не отслеживает уже посещенные каталоги.
•	Если вы передадите относительный путь, не меняйте текущий рабочий каталог между повторными выполнениями функции os.walk(). Функция os.walk() никогда не изменяет текущий каталог и предполагает, что его вызывающая сторона тоже не изменяет.
Примеры практического применения функции os.walk().
В этом примере считается количество байтов, занятое только файлами, в каждом начальном каталоге, за исключением каталога CVS:
import os
from os.path import join, getsize

for root, dirs, files in os.walk(os.path.abspath(os.path.curdir)):
    print(f'Директория, <<{root}>>', "занимает", end=" ")
    print(sum([getsize(join(root, name)) for name in files]), end=" ") – знаки […] 
                                                                   можно не ставить
    print("байт. Содержит", len(files), "файла")
    if 'CVS' in dirs:
        # не просматриваем каталог `CVS`
        dirs.remove('CVS')
Результат выполнения кода:
Директория: <<D:\Works of Skillbox\1. Python Basic\22\for test_14>> занимает 106 байт. Содержит 2 файла
Директория: <<D:\Works of Skillbox\1. Python Basic\22\for test_14\f_1>> занимает 0 байт. Содержит 2 файла
Директория: <<D:\Works of Skillbox\1. Python Basic\22\for test_14\f_1\f_3>> занимает 0 байт. Содержит 2 файла
Директория: <<D:\Works of Skillbox\1. Python Basic\22\for test_14\f_1\f_5>> занимает 0 байт. Содержит 0 файла
Директория: <<D:\Works of Skillbox\1. Python Basic\22\for test_14\f_1\f_5\f_6>> занимает 0 байт. Содержит 0 файла
Директория: <<D:\Works of Skillbox\1. Python Basic\22\for test_14\f_1\f_5\f_6\f_7>> занимает 0 байт. Содержит 1 файла 
В следующем примере простая реализация функции shutil.rmtree(). В функции os.walk() указан обход дерева каталогов снизу вверх, это очень важно, т. к. функция os.rmdir() не позволяет удалить каталог, пока он не пуст:
ВНИМАНИЕ! В примере удаляется все из каталога, указанного в переменной top, при условии, что нет символических ссылок. Это опасно! Например, если top == '/', это может удалить все файлы на диске.
import os

for root, dirs, files in os.walk(top, topdown=False):
    for name in files:
        os.remove(os.path.join(root, name))
    for name in dirs:
        os.rmdir(os.path.join(root, name))
Создаем каталог с помощью функций mkdir() и makedirs()
Для создания новой папки используется функция os.mkdir(). А для создания сразу несколько вложенных папок функция os.makedirs().
Синтаксис: os.mkdir(path, mode=0o777)
Функция mkdir() модуля os создает каталог с именем path с режимом прав доступа mode к каталогу. 
Если каталог уже существует, вызывается исключение FileExistsError.
При создании нового каталога с помощью os.mkdir() все родительские каталоги должны уже существовать. Пример ниже:
В примере ниже с помощью функции mkdir() создается каталог f_1:
import os

os.chdir('for test_13')

os.mkdir('f_1')                       # Создание папки f_1
os.mkdir(os.path.join('f_2', 'f_3'))  # Выдаст ошибку FileExistsError
Синтаксис: os.makedirs(path, mode=0o777, exist_ok=False)
Функция makedirs() модуля os похожа на os.mkdir(). Разница между ними в том, что os.makedirs() может не только создавать отдельные каталоги, но также может использоваться для создания деревьев каталогов (т.е. может создавать любые необходимые промежуточные папки, чтобы гарантировать существование полного пути). Т.О. функция makedirs()  рекурсивно создает все промежуточные каталоги, если они не существуют, и создает все каталоги промежуточного уровня, необходимые для хранения конечного каталога.
Если конечный каталог уже существует, вызывается исключение FileExistsError.
Если exist_ok имеет значение False (по умолчанию) и целевой каталог уже существует, то возникает ошибка FileExistsError.
import os

os.chdir('for test_13')

os.makedirs(os.path.join('f_2', 'f_3', 'f_4'))     # Создание дерева каталогов
Режим прав доступа mode в обеих функциях дает владельцу и пользователям группы права на чтение, запись и выполнение. Режим по умолчанию — 0o777, и биты прав доступа к файлам существующих родительских каталогов не изменяются. Возможные значения mode можно узнать тут: https://docs-python.ru/standart-library/modul-os-python/funktsija-mkdir-modulja-os/.
Создание пустого файла
Нет ничего проще, чем создать пустой файл, достаточно открыть несуществующий файл с флагом 'x':
file = open('empty.txt', 'x')
file.write('Hello World!')
file.close()
Конечно, можно использовать флаг 'w', но тогда уже существующий файл будет стёрт (перезаписан). А с флагом 'x' передаваемым в функцию open() будет либо создан новый файл, если такого файла пока нет, либо будет выброшена ошибка FileExistsError, что такой файл уже существует.
Переименование и перемещение файлов и папок с помощью функции rename()
C помощью функции rename(src, dst) можно переименовывать и перемещать файлы/папки. Причем папки будут перемещены вместе с содержимым (другими файлами и папками).
Синтаксис: rename(src, dst), где src (source) – путь до исходного файла/папки, 
dst (destination) – путь до файла/папки с новым именем (названием). В скобках метода указывается относительный или абсолютный путь до файла/папки. Если вместо путей, в скобках метода указаны только названия файлов/папок, то подразумевается, что функция применяется для файлов/папок в текущем рабочем каталоге (текущей директории скрипта). Этот принцип распространяется для всех методов модулей os, shutil, pathlib.
Если в dst указать путь до файла/папки, который находится в каталоге, отличном от указанного в src, то произойдет перемещение файла/папки из каталога src в каталог dst, причем с именем указанным в dst (т.е. имя файла/папки в dst можно изменить, тогда получится одновременно перемещение с переименованием). Будет ли каталог dst пустым или не пустым не имеет значения.
Если имя dst (название файла/папки) уже существует (т.е. файл/папка с именем на которое мы хотим переименовать уже существует), то операция os.rename(), в ОС Windows вызовет ошибку: FileExistError. Поэтому нужна предварительная проверка на существование.
Если файла src нет по указанному пути то возникнет ошибка: FileNotFoundError.
Примечание: Каталог, директория и папка – это одно и то же, т.е. синонимы.
Подробнее о команде см: https://docs-python.ru/standart-library/modul-os-python/funktsija-rename-modulja-os/.
import os

file_name = 'file.docx'
abs_path_file_old = r'D:\Works\Python Basic\22\for test_1\file.docx'
abs_path_file_new = r'D:\Works\Python Basic\22\for test_1\file_2.docx'

os.rename(abs_path_file_old, abs_path_file_new)
Переименование и перемещение файлов и папок с помощью функции renames()
Функция renames() модуля os рекурсивно переименовывает каталоги или файлы. Функция os.renames() служит тем же целям что и функция os.rename(), но позволяет создавать промежуточные директории. В ней возникают те же исключения и ошибки, что и при использовании метода os.rename(). 
Т.О. функция os.renames() работает аналогично функции os.rename(), за исключением того, что сначала делается попытка создания любых промежуточных каталогов (указанных во втором аргументе функции в виде пути), необходимых для того, чтобы новое имя пути было правильным (и было созадно). После перемещения, каталоги соответствующие крайним правым сегментам пути старого имени, будут удалены с помощью removedirs() автоматически. И, следовательно, эта функция может завершиться ошибкой при создании новой структуры каталогов, если у вас нет прав, необходимых для удаления изначального каталога или файла.
Пример использования:
>>> os.chdir('C:\\example')
>>> os.listdir()
['file.txt']
>>> os.renames('file.txt', 'some-dir\\some-file.txt')
>>> os.listdir()
['some-dir']
>>> os.chdir('some-dir')
>>> os.listdir()
['some-file.txt']
С помощью функция os.renames() удобно подготовить заранее все необходимые папки для дальнейшей работы (если файловая структура заранее известна).
Переименовывать можно не только один каталог, но и несколько папок сразу, только если все они находятся в одной иерархической цепочке. Для этого достаточно вызвать функцию renames() и передать ей путь к конечной директории в качестве первого аргумента. В роли же второго параметра выступает аналогичный адрес к папке, но только с новыми именами всей цепочки. Следующий пример демонстрирует правильное использование функции renames(), за счет чего было произведено переименование директорий folder, first и second в catalog, one и two.
import os
os.renames(r"D:\folder\first\second", r"D:\catalog\one\two")
Переименование и перемещение файлов и папок с помощью функции replace()
С помощью функции os.replace(src, dst) можно заменить файлы и папки.
Простыми словами функция rename(file1, file2) - перемещает или переименовывает файл file1 в file2, причем если file2 уже существует, то выйдет ошибка FileExistError. Аналогично и для каталогов.
А функция replace(file1, file2) - если файл (file2) уже существует, то она заменит его на файл file 1 (т.е. файл file2 будет перезаписан файлом file1). Причем, если то же самое проделывать с каталогами replace(folder1, folder2) и каталог folder2 уже существует в месте назначения, то замены не произойдет и выйдет ошибка PermissionError: [WinError 5] Отказано в доступе.
Две версии практически одинаковые функции os.rename() и os.replace() существуют по исторической причине, причем Path.rename() и Path.replace() модуля pathlib (см. ниже) повторяют функции os.rename() и os.replace().
1.	При перемещении или переименовании файла/папки с помощью функции os.rename(), в случае если файл/папка уже существует в месте назначения, результат будет зависеть от ОС:
•	В Win: будет ошибка OSError.
•	В POSIX системах (т.е. в Unix-подобных ОС): будет выполнено перемещение или переименование, и будет выполнена замена, если файл или папка уже существует.
2.	При перемещении или переименовании файла/папки с помощью функции os.replace(), в случае если файл/папка уже существует в месте назначения, перемещение или переименование будет выполнено в любом случае. Просто если файл/папка уже существует, будет выполнена его/ее замена без всяких ошибок. 
Поэтому, лучше использовать os.replace() или Path.replace(), потому что они не зависят от ОС. Перед их использованием лучше проверять, что такая файл/папка уже не существует в месте назначения, иначе они могут быть заменены и утрачены.
Т.О. Path.rename() и os.rename() гарантированно будут работать (перемещать или переименовывать существующий файл/папку) только в ОС Unix / Linux.
Path.replace и os.replace() являются кроссплатформенными и перемещают или переименовывают существующий файл/папку независимо от платформы (т.е. независимо от ОС).
Еще один минус в том, что обе функции (и os.rename() и os.replace()) не поддерживают перемещение файлов из разных файловых систем, в отличие от модуля shutil. Поэтому для перемещения файлов рекомендуется использовать shutil.move(). Работа модулей pathlib и shutil будет описана ниже.
Удаление файлов и пустых папок
Для удаления файла в модуле os применяется функция remove(), а для удаления каталога  —  функция rmdir(). Попытка же удалить директорию с помощью remove() вызовет ошибку. Рассмотрим применение этих функций ниже.
Синтаксис: os.remove(path). В скобках метода указывается относительный или абсолютный путь  до файла.
В этом фрагменте кода мы с помощью функции remove() удаляем файл «file.docx».
import os

file_name = 'file.docx'
abs_path_file = r'D:\Works\Python Basic\22\for test_1\file.docx'

if os.path.exists(abs_path_file):
    os.remove(abs_path_file)
else:
    print('Такого файла нет в каталоге!')
Если удаляемого файла нет в каталоге, то выйдет ошибка: FileNotFoundError: [WinError 2] Не удается найти указанный файл: <путь к файлу>. Поэтому файл лучше удалять с предварительной проверкой на существование. Если путь является каталогом, возникает исключение: IsADirectoryError.
Синтаксис: os.rmdir(path). В скобках метода указывается относительный или абсолютный путь  до каталога.
Пример использования представлен ниже:
>>> os.rmdir('poems')
>>> os.path.exists('poems')
False
Функция rmdir() модуля os удаляет каталог с путём path до него. Если директория path не существует или не является пустым каталогом, соответственно возникает исключение FileNotFoundError или OSError. Т.О. с помощью функции rmdir() можно удалить только пустую папку. А для удаления целых деревьев каталогов (т.е. папку со всем содержимым) можно использовать функцию shutil.rmtree() (см. ниже).
Аргумент path может принимать объекты, представляющие путь файловой системы, такие как pathlib.PurePath.
Подробнее см: https://docs-python.ru/standart-library/modul-os-python/funktsija-remove-modulja-os/.
Удаление множества пустых папок с помощью функции removedirs()
Функция os.removedirs() удаляет каталоги рекурсивно. Работает подобно функции os.rmdir() за исключением того, что, если конечный каталог успешно удален, os.removedirs() пытается последовательно удалить каждый последующий родительский каталог, указанный в пути, до появления ошибки. Появления ошибки обычно означает, что родительский каталог не пуст.
Например, os.removedirs('foo/bar/ baz') сначала удалит каталог 'foo/bar/baz', если он пуст, а затем удалит 'foo/bar' и 'foo', если они окажутся пустыми. Взывает исключение OSError, если конечный каталог не может быть успешно удален (т.е. окажется не пустым).
Разделение пути на имя файла и остальной путь
Функция split(path) разбивает путь path на две части, возвращая результат в виде кортежа (head, tail) или (голова, хвост). Второй элемент кортежа tail содержит последнюю часть пути, а первый head - все, что ей предшествует. Хвост никогда не будет содержать косую черту. 
Если путь path заканчивается разделителем os.sep (т.е. /), tail будет пустой строкой.
Если в пути path нет даже os.sep, head будет пустой.
Если путь path пустой, то и head и tail будут пустыми строками.
import os.path

os.path.split('/home/User/Desktop/file.txt')# => ('/home/User/Desktop', 'file.txt')
os.path.split('/home/User/Desktop/')        # => ('/home/User/Desktop', '')
os.path.split('/home/User/Desktop')         # => ('/home/User', 'Desktop')
os.path.split('/')                          # => ('/', '')
os.path.split('.')                          # => ('', '.')
os.path.split('')                           # => ('', '')
Получение имени файла и директории
Иногда для взаимодействия с документом необходимо получить его полное имя, включающее расширение, а не абсолютный путь к нему на диске. Преобразовать путь к файлу в название файла позволяет функция basename(), которая содержится в подмодуле path модуля os. Она эквивалентна второй части, возвращаемой функцией split(). Следующий пример показывает преобразование пути к файлу test.txt в простое имя файла.
import os
print(os.path.basename("D:/test.txt"))
Результат выполнения кода:
test.txt
Обратная ситуация возникает тогда, когда пользователю нужно получить только путь к файлу, без его названия. Это поможет сделать функция os.dirname(), которая возвращает путь к файлу в виде строки. Она эквивалентна первой части, возвращаемой функцией split().Пример показан ниже. 
import os
print(os.path.dirname("D:/folder/test.txt"))
Результат выполнения кода:
D:/folder
Получение расширения файла
Получить расширение файла можно с помощью функции splitext() модуля os. Она возвращает кортеж, 1-ый элемент которого это имя, а 2-ой – расширение. В данном случае нам нужен 2-ой элемент. Индекс 2-ого элемента равен единице, так как отсчет их идет от нуля.
import os
full_name = os.path.basename(r'C:\python3\file.tar.gz')
ext = os.path.splitext(full_name)[1]
print(ext)
Результат
.gz
Запуск на исполнение. Функция startfile()
Встроенные функции библиотеки os позволяют запускать отдельные файлы и папки прямиком из программы. С этой задачей прекрасно справляется метод startfile, которому стоит передать адрес необходимо объекта. Программное обеспечение (ПО), используемое для открытия документа, определяется средой автоматически. Например, при запуске обычного файла test.txt, как это сделано в следующем примере, задействуется стандартный блокнот. Если передать функции ссылку на директорию, она будет открыта при помощи встроенного менеджера файлов.
import os
os.startfile(r"D:\test.txt")
Синтаксис: os.startfile(path[, operation])
Параметры:
•	path - относительный путь до запускаемого файла,
•	operation - задокументированный в Microsoft командный глагол.
Возвращаемое значение:
•	нет.
Описание:
Функция startfile() модуля os запускает файл с помощью связанного с ним приложения на основе расширения.
Если аргумент operation не указан или 'open', то это действует как двойной щелчок по файлу в проводнике Windows.
Когда задается другая операция operation, то она должна быть "командным глаголом", который указывает, что следует делать с файлом. Общие глаголы, задокументированные Microsoft, - это 'print' и 'edit' (для использования в файлах), а также 'explore' и 'find' (для использования в каталогах).
Как только запускается связанное приложение, функция os.startfile() завершается и нет возможности дождаться закрытия приложения и получить статус выхода приложения.
Аргумент пути path указывается относительно текущего каталога. Если вы хотите использовать абсолютный путь, то необходимо убедится, что первый символ не является косой чертой '/', т. к. базовая функция Win32 ShellExecute() с ним работать не будет. Чтобы убедиться в правильности пути для Win32 - используйте функцию os.path.normpath().
Пример открытия файла .docx для редактирования в приложении Microsoft Word.
import os
# файл откроется в приложении Microsoft Word
os.startfile('test.docx', 'edit')

# файл откроется в блокноте, если с расширением 
# `.txt` не ассоциировано другое приложение.
os.startfile('test.txt', 'edit')
Модуль shutil
Модуль shutil предлагает ряд высокоуровневых операций над файлами и коллекциями файлов. В частности, предусмотрены функции, которые поддерживают копирование, перемещение, переименование и удаление файлов и папок.
Примечание: Даже функции копирования файлов более высокого уровня shutil.copy(), shutil.copy2() не могут копировать все метаданные файла.
•	На платформах POSIX (Unix/Linux) это означает, что владелец файла и группа будут потеряны, а также ACL.
•	В Mac OS ветвь ресурса и другие метаданные не используются. Это означает, что ресурсы будут потеряны, а тип файла и коды создателей будут неправильными.
•	В Windows владельцы файлов, списки ACL и альтернативные потоки данных не копируются.
Начиная с Python-3.8 все функции, включающие в себя функцию копирования файлов shutil.copyfile(), shutil.copy(), shutil.copy2(), shutil.copytree() и shutil.move(), могут использовать системные вызовы fast-copy для конкретной платформы, чтобы копировать файл более эффективно. "Быстрое копирование" означает, что операция копирования происходит внутри ядра, избегая использования буферов пространства пользователя в Python.
Если операция быстрого копирования завершится неудачно и данные в файл назначения не будут записаны, модуль shutil автоматически откажется от использования менее эффективной функции copyfileobj().
Копирование файлов с помощью функции copy()
Функция copy() модуля shutil копирует файл src из какого-либо каталога в любой другой каталог либо текущий рабочий каталог, но с именем dst. Но: при попытке копирования папки (независимо от того пустая она или нет) в какую либо другую папку выйдет ошибка. 
import shutil
path_1 = shutil.copy('folder_1', 'folder_2')  		# Это выдаст ошибку
Аргументы src и dst должны быть строками. Функция copy() возвращает путь к вновь созданному файлу.
Синтаксис: shutil.copy(src, dst)
где src - исходное место/путь копируемого файла;
      dst - место/путь назначения нового файла.
Если dst указывает на каталог, то файл в каталоге src будет скопирован в каталог dst с именем файла из каталога src.
import shutil
path_1 = shutil.copy('folder_1\\1.jpg', 'folder_2')
Если src и dst это один и тот же каталог и имена файлов совпадают, то это приведет к ошибке, а если имена разные, то произойдет копирование файла src в тот же каталог, но с именем dst (как бы получается копирование с переименованием).
import shutil
path_1 = shutil.copy('1.txt, '1.txt)	# Это выдаст ошибку
path_2 = shutil.copy('1.txt', '2.txt')	# Нормально сработает
Если src и dst это разные каталоги, но файл с именем в src уже есть в папке dst, то он будет заменен без всяких ошибок.
Функция shutil.copy() копирует данные файла и режим доступа к файлу. Другие метаданные, такие как время создания и время изменения файла не сохраняются (не копируются). Чтобы сохранить все метаданные файла из оригинала, используется функция shutil.copy2().
Копирование файлов с помощью функции copyfile()
В отличие от функции copy() функция copyfile() копирует файл src из какого-либо каталога, но только в текущий рабочий каталог с именем dst. Все остальное также как и в функции copy().
Метаданные, такие как время создания и время изменения файла также не копируются.
import shutil
path_1 = shutil.copyfile('1.txt', '2.txt') 		# Нормально сработает
path_2 = shutil.copyfile('1.txt', 'f_1') 			# Это выдаст ошибку
path_3 = shutil.copyfile('folder_1\\1.jpg', '3.jpg') 	# Нормально сработает
Копирование файлов с помощью функции copy2()
Функция copy2() модуля shutil работает идентично функции shutil.copy() за исключением того, что shutil.copy2() пытается сохранить метаданные файла.
На платформах, где некоторые функции модуля недоступны, функция shutil.copy2() сохранит все возможные метаданные. Она не вызывает исключение, если не может сохранить метаданные файла. 
Функция shutil.copy2() использует функцию shutil.copystat() для копирования метаданных файла.
Т.О. функция copy2() является более универсальной и полностью скопирует информацию из текстового файла, а также все сведения о нем. 
Пример приведен ниже. В нем написана функция, которая будет проходиться по файлам, и копировать их из директории src в директорию dst. При вызове этой функции указано, с какого по какой номер файла проводить копирование (при условии, что мы переименовали их в номера). В примере копируются конкретно jpg-файлы, можно указать и что-то другое. 
import os
import shutil

os.chdir('some_folder')
def copy_files(src, dst, start, stop):
    fnames = [f'{i}.jpg' for i in range(start, stop)]
    for fname in fnames:
        src_file = os.path.join(src, fname)
        dst_file = os.path.join(dst, fname)
        shutil.copy2(src_file, dst_file)

copy_files('folder_1', 'folder_2', 1, 3)
Копирование содержимого каталога с помощью copytree() (без самого каталога)
Для копирования содержимого папки (но не папку вместе с содержимым!) в другую папку используется конструкция shutil.copytree(src, dst). Она рекурсивно копирует все дерево каталогов с корнем в src в каталог с именем dst и возвращает путь к каталогу назначения dst. 
Обратите внимание, что dst не должно быть уже существующей папкой (т.е. папки dst в которую будет произведено копирование содержимого папки srt на момент копирования не должно существовать). Копирование произойдет в папку dst с одновременным ее созданием. Если же каталог dst уже существует, то выйдет ошибка FileExistsError.
Для копирования папки в уже существующую папку можно использовать такой лайфхак: Копирование содержимого исходной папки src в другую папку dst, но содержащую подпапку с именем исходной папки src (т.е. по пути: dst/src), равносильно копированию папки src в папку dst. Например:
# Пример 1
shutil.copytree("f_2", "f_2/test1")   # Копирование содержимого папки f_2 внутрь
                                        неё самой же но в подпапку test1
# Пример 2
shutil.copytree("f_2", "f_1/f_2")   # Копирование содержимого папки f_2 внутрь
                                      папки f_1, но в подпапку f_2, равносильно
                                      копированию папки f_2 в папку f_1
# или
shutil.copytree("f_2", os.path.join('f_1', 'f_2'))	# Код под любою ОС
Из примеров видно, что функция copytree(src, dst), перед копированием, создает промежуточные директории (если они указаны во втором аргументе функции dst в виде компонентов пути), необходимые для того, чтобы осуществить копирование содержимого папки srt в папку с путем dst. 
Т.О. в dst мы должны указать именно новую папку (отличную от src), так как функция copytree(src, dst) не позволяет копировать содержимое исходной папки src в уже существующую папку.
Если в src будет указан файл вместо папки, то выйдет ошибка: NotADirectoryError.
Копирование одной пустой папки src в другую пустую папку dst просто создаст новую папку dst.
import os
import shutil

os.chdir('for test_12')

path = shutil.copytree('f_2', 'f_1')   # Копирование содержимого непустой папки f_2
                                         в пустую папку f_1
print(path)

shutil.copytree("f_2", "f_2/test1")   # Копирование содержимого папки f_2 внутрь
                                        неё самой же но в подпапку test1
shutil.copytree("f_2", "f_1/f_2")   # Копирование содержимого папки f_2 внутрь
                                      папки f_1, но в подпапку f_2, равносильно
                                      копированию папки f_2 в папку f_1
shutil.copytree("f_2", os.path.join('f_1', 'f_2'))   # Копирование содержимого
                                                  папки f_2 внутрь папки f_1, но в
                                                  подпапку f_2, равносильно
                                                  копированию папки f_2 в папку f_1
shutil.copytree("f_2", "f_1")   # Это выдаст ошибку

shutil.copytree('1.txt', 'f_1')   # Это выдаст ошибку

shutil.copytree('f_3', 'f_1')   # Копирование содержимого пустой папки f_3 в другую
                                  пустую папку f_1
# f – это папка (от folder)
Синтаксис: shutil.copytree(src, dst, symlinks=False, ignore=None,                 copy_function=copy2, ignore_dangling_symlinks=False, dirs_exist_ok=False).
Вообще у всех функций приведенных тут есть доп. параметры, но мы рассматриваем только основные, это src и dst, и иногда, некоторые другие.
Параметр ignore=None - функция пропуска файлов.
Если параметр ignore задан(т.е. ignore не None), то это должна быть вызываемая функция, которая будет получать в качестве аргументов каталог dst и список его содержимого, возвращаемый os.listdir(). Поскольку shutil.copytree() вызывается рекурсивно, то игнорирование будет вызываться один раз для каждого вложенного копируемого каталога.
Вызываемый объект должен возвращать последовательность имен каталогов и файлов относительно текущего каталога, то есть подмножества элементов во втором аргументе. Эти имена будут игнорироваться в процессе копирования. Функция shutil.ignore_patterns() может использоваться для создания такого вызываемого объекта, который игнорирует имена на основе шаблонов в стиле glob.glob() (см. ниже).
Пример, который использует помощник в виде функции shutil.ignore_patterns(). Копируется все, кроме файлов .pyc и файлов или каталогов, чье имя начинается с tmp.
from shutil import copytree, ignore_patterns

copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))
shutil.ignore_patterns(*patterns) - функция, которая создаёт функцию, которая позволяет выборочно копировать файлы из каталогов. *patterns - шаблоны типа glob.glob().
которая может быть использована в качестве параметра ignore для функции copytree(),Т.е. это функция для выборочного копирования файлов из каталога,
Функцию shutil.ignore_patterns() можно использовать в качестве вызываемого объекта для аргумента ignore функции shutil.copytree(), для игнорирования файлов и директорий, которые соответствуют glob-style шаблонам, т.е. файлы и каталоги будут пропускаться в соответствии с одним из предоставленных шаблонов *patterns типа glob.glob().
Перемещение и переименование файла/папки
Функция move(src, dst) модуля shutil рекурсивно перемещает любой файл/папку (даже непустую) из src в другое место dst и возвращает место назначения dst.
Если имя dst (название файла/папки) уже существует (т.е. файл/ папка с именем на которое мы хотим переименовать уже существует по данному пути), то операция 
shutil.move(src, dst)  в отличие от операции os.rename(), не вызовет ошибки, а просто переместит/переименует файл/папку src с заменой существующего файла/папки. Поэтому предварительная проверка на существование тут не обязательна. В случае успеха, функция shutil.move(src, dst) вернёт новое местоположение файла.
Если src и dst это один и тот же каталог и имена файлов совпадают, то это не приведет к ошибке, а файл останется в той же папке.
Если файла/папки src нет по указанному пути, то возникнет ошибка: FileNotFoundError.
Перемещение файла в еще несуществующую папку создаст файл с именем этой папки, но без расширения.
Несмотря на то, что модуль os содержит специальную функцию rename() для переименования, нужно понимать, что в рамках одной файловой системы перемещение и переименование — это одно и то же. Когда вы перемещаете или переименовываете файл, его содержимое не переписывается на носителе в другое место, просто файловая система теперь помечает (прописывает) его положение (путь) другим путём.
import os
import shutil

os.chdir('for test_10')

shutil.move('1.txt', 'f_2')     # Перемещение файла в другую папку

shutil.move('1.txt', '1.txt')   # Переименование файла в текущей рабочей директории
                                  на то же имя что и было
path = os.path.join('f_1', '1.jpg') # Путь к другой папке
shutil.move(path, '3.jpg')          # Перемещение c переименованием файла из другой
                                      папки в текущий рабочий каталог
shutil.move('f_1', 'f_2')           # Перемещение непустой папки в другую папку

shutil.move('f_3', 'f_1')           # Перемещение пустой папки в другую папку

shutil.move('1.txt', '2.txt')   # Переименование файла в текущей рабочей директории

shutil.move('1.txt', os.path.join('f_2', '2.txt'))  # Перемещение с переименованием
                                                      файла в другую папку
shutil.move('f_4', 'f_5')   # Переименование папки в текущей рабочей директории

shutil.move(os.path.join('f_2', 'f_4'), os.path.join('f_2', 'f_5'))# Переименование
                                                          папки в другой директории
shutil.move('1.txt', 'f_10')   # Перемещение файла в несуществующую папку
# f – это папка (от folder)
Функция shutil.move() гораздо «умнее» чем функции os.rename() и os.replace(), т.к. в ней для перемещения файлов, в какой либо каталог не нужно указывать имя явно,  а достаточно указать имяя папки в которую нужно переместить файл.
Удаление любой папки в том числе и непустой папки (всего дерева каталогов)
Как уже было сказано выше, удалить файл можно с помощью функции os.remove(), а пустую папку с помощью функции os.rmdir().
Для удаления непустой папки вместе с содержимым используется функция rmtree() модуля shutil. Функция rmtree() рекурсивно удаляет содержимое папки/каталога (все дерево каталогов).
Синтаксис: shutil.rmtree(path), где path - каталог удаления (путь до исходного каталога).
Путь path должен указывать на каталог, но не символическую ссылку на каталог.
Возвращаемое значение: None
Если каталога нет по указанному пути, то возникнет ошибка: FileNotFoundError.
Если с помощью функции os.rmdir() попытаться удалить файл выйдет ошибка: NotADirectoryError: [WinError 267] Неверно задано имя папки.
Примечание: будьте осторожны, команды удаления стирают файл, а не перемещают его в корзину, вне зависимости от операционной системы! После такого удаления восстановить файл может быть сложно или вовсе невозможно.
import os
import shutil

os.chdir('some_folder')

shutil.rmtree('folder_1')    	                       # Нормально сработает
shutil.rmtree(os.path.join('folder_1', '1', '2'))    	# Нормально сработает
shutil.rmtree('1.txt')                               # Это выдаст ошибку
Модуль glob
Модуль glob находит все пути, соответствующие указанному шаблону, в соответствии с правилами, используемыми оболочкой Unix (Linux). Результаты возвращаются в произвольном порядке.
Расширение переменных пути при указании тильды ~/path не выполняется, но символы 
'*', '?' и диапазоны символов, такие как [a-z] или [0-9], будут работать правильно. 
Обратите внимание, что в отличие от fnmatch.fnmatch(), модуль glob рассматривает имена файлов, начинающиеся с точки '.', как особые случаи.
•	Для расширения переменных пути при указании тильды ~ используйте функцию os.path.expanduser() и os.path.expandvars() (т.е. для использования тильды "~" и переменных окружения необходимо использовать os.path.expanduser() и os.path.expandvars()).
•	Для буквального совпадения метасимволов заключите их в скобки (т.е. для поиска спецсимволов, нужно заключать их в квадратные скобки). Например [?] Соответствует символу ?.
Функция fnmatch(filename, pattern) модуля fnmatch проверяет, соответствует ли строка имени файла filename шаблонной строке pattern, возвращая True или False. В примере ниже будут напечатаны все имена файлов в текущем каталоге с расширением .txt:
import fnmatch
import os

pattern = '*.txt'

for name in os.listdir('.'):
    if fnmatch.fnmatch(name, pattern):
        print(name)

Справка:
Зачем нужны шаблоны? Часто требуется выполнить однотипные действия над группой файлов. Описывать эти действия по отношению к каждому отдельному файлу было бы трудоемкой задачей. На помощь приходят шаблоны, которые позволяют выделить группу файлов, чьи имена удовлетворяют определенным условиям, из общей массы. Шаблоны часто используют для поиска файлов.
Шаблоны имен файлов и каталогов задаются с помощью специальных символов:
1)	* – звездочка;
2)	? – знак вопроса;
3)	[ ] – квадратные скобки.
1)	Звездочкой (*) в шаблоне обозначают любую группу символов. Их количество роли не играет. Это могут быть пять, десять, один символ или даже ни одного. Так, например, шаблону, состоящему всего из одного символа *, будет соответствовать абсолютно любой файл/папка. Использование шаблона *.html позволит выделить все html-файлы, а шаблон my*.odt – файлы, начинающиеся с "my" и оканчивающиеся на ".odt". Шаблон *2010* определяет все файлы и папки, в именах которых присутствует группа символов 2010.
2)	Знаком вопроса (?) в шаблоне обозначают любой один символ. Например, под шаблон otchet.??? подойдут файлы, имеющие расширение из любых трех букв, но начинающиеся именно так, как задано в шаблоне. Шаблону descrip?ion.pdf будут соответствовать файлы с заданным именем, но вместо знака вопроса может стоять любой символ.
3)	Использование квадратных скобок [ ]  со списком вложенных значений позволяет осуществлять более гибкий поиск файлов. Пусть требуется найти все файлы, имена которых начинаются с буквы m, при этом регистр не учитывается. Шаблон будет выглядеть так: [mM]*.
Если надо одновременно найти файлы, начинающиеся на буквы, идущие подряд в алфавите, то задается диапазон. Например, под шаблон [m-pM-P]???.png подойдут все файлы с расширением png, имена которых состоят из четырех букв, причем первая буква m или n или o или p без учета регистра.
Примечание 1: понятно, что в одном шаблоне имени файла можно использовать разные специальные символы. Например, [aA]*.???.
Примечание 2: После версии Python 3.5 функция glob поддерживает специальный подстановочный знак «**», который может соответствовать всем файлам и каталогам по указанному пути, включая все файлы и каталоги в подкаталогах. Это эквивалентно рекурсивному вызову этой функции. Чтобы использовать этот шаблон, вы должны добавить/использовать параметр recursive = True. В случае сложной структуры каталогов использование этого подстановочного знака может привести к снижению производительности, что приведет к снижению производительности всей программы и должно использоваться с осторожностью!

Синтаксис:
file_list = glob.glob(pathname, *, root_dir=None, dir_fd=None, recursive=False)
file_iter = iglob.iglob(pathname, *, root_dir=None, dir_fd=None, recursive=False)
Параметры:
•	pathname - путь к каталогу файловой системы,
•	root_dir=None - путь, действует так же, как изменение текущего каталога.
•	dir_fd=None - путь относительно дескриптора каталога.
•	recursive=False - просмотр файлов в подкаталогах.
Возвращаемое значение:
•	список найденных файлов и/или папок.
Функция glob() модуля glob возвращает список путей файлов и папок (в том числе и скрытых), которые находятся в каталоге pathname, который должен быть строкой, содержащей спецификацию пути (подстановочные wildcard-выражения). Т.е. модуль glob может использовать wildcards (подстановочные знаки, символы подстановки) в стиле оболочки Unix для сопоставления файлов и папок в определенном формате, аналогично функции поиска файлов в Windows. Т.О. функция glob() принимает шаблон в качестве входного параметра и возвращает список файлов и подкаталогов внутри указанного каталога.
Функция iglob() возвращает итератор, который выдает те же значения, что и функция glob(), только не сохраняет все пути в оперативной памяти одновременно.
Правила шаблонов применяются к сегментам имени файла (их действие заканчивается на разделителе каталогов, /). Имя пути pathname может быть абсолютным, например /usr/src/Python-1.5/Makefile или относительным, например ../../Tools/*/*.gif и может содержать символы подстановки (wildcards) в стиле оболочки Unix (*, ? и например [0-9]). Сортировка результатов зависит от файловой системы. 
Если в pathname указан только шаблон, то подразумевается относительный путь (относительно рабочего каталога) и функция iglob() применяется для файлов/папок в текущем рабочем каталоге. В этом случае будет возвращен список относительных путей к файлам и/или папкам (т.е. названия файлов и/или папок согласно шаблону).
Если же в pathname указан абсолютный путь с шаблоном, то тогда будет возвращен список абсолютных путей к файлам и/или папкам согласно шаблону.
Если аргумент root_dir не равен None (доступно с версии python 3.10), это должен быть объект, похожий на путь, указывающий корневой каталог для поиска. На функцию glob() он действует так же, как изменение текущего каталога перед его вызовом. Если имя пути является относительным, то результат будет содержать пути относительно root_dir.
Эта функция может поддерживать пути относительно дескрипторов каталогов с параметром dir_fd (доступно с версии python 3.10).
Если для аргумента recursive задано значение True, то шаблон ** будет соответствовать любым файлам и нулю или более каталогам (т.е. любому количеству каталогов, в том числе ни одного), подкаталогам и символическим ссылкам на каталоги. Если за шаблоном следует os.sep или os.altsep, файлы не будут совпадать.
Функция escape() позволяет создать подходящий шаблон, в котором специальные символы экранируются таким образом, чтобы они не заменялись никакими другими значениями и не интерпретировались как специальные модулем glob. Подробнее по функции escape() см в инете.
Примечание.
Использование шаблона ** в больших деревьях каталогов может занять слишком много времени. Аргументы root_dir и dir_fd были добавлены именно в Python 3.10.

Подстановочные знаки, поддерживаемые модулем glob
Wildcards	Функция
*	Соответствует любому количеству символов, в том числе даже ни одного (т.е. 0 или более любых символов). 
**	Соответствует всем файлам, каталогам, подкаталогам и файлам в подкаталогах (начиная с версии 3.5)
?	Соответствует одному любому символу.
[exp]	Соответствует символам в указанном диапазоне, например: [5-9] - соответствует символам в диапазоне от 5 до 9, [e-f] - соответствует символам в диапазоне от e до f
[!exp]	Совпадение символов, которые не находятся в указанном диапазоне



Примеры использования:
1)	Для возврата списка всех exe файлов, которые находятся по пути p можно использовать модуль os:
import glob
import os

p = 'c:/windows'
e = [x for x in os.listdir(p) if os.path.isfile(os.path.join(p, x)) and os.path.splitext(x)[-1] == '.exe']
print(e)
Но с помощью модуля glob это можно сделать проще и красивее, т.к. он как раз и предназначен для поиска файлов по шаблонам (паттернам):
import glob
import os

p = 'c:/windows'
print(glob.glob1(p, '*.exe'))       # Список экзешников
print(glob.glob1(p, '*[0-9].exe'))# Список экзешников имя кот.заканчивается на цифры
2)	Рассмотрим каталог, содержащий следующие файлы: 1.gif, 2.txt, card.gif и вложенный каталог sub, который содержит только файл 3.txt. Функция glob.glob() даст следующие результаты. Обратите внимание, как сохраняются любые ведущие компоненты пути.
import glob

print(glob.glob('./[0-9].*'))                  # Выведет ['.\\1.gif', '.\\2.txt']
print(glob.glob('*.gif'))                      # Выведет ['1.gif', 'card.gif']
print(glob.glob('?.gif'))                      # Выведет ['1.gif']

# Поиск файлов по шаблону *.txt во всех каталогах и подкаталогах (т.е. рекурсивный
# поиск файлов), начиная с текущего каталога, т.к. в pathname указан отн-ный путь print(glob.glob('**/*.txt', recursive=True))  # Выведет ['2.txt', 'sub\\3.txt']
# Рекурсивный поиск файлов и папок (во всех каталогах и подкаталогах текущей папки)
print(glob.glob('**', recursive=True))         # Выведет ['1.gif',  '2.txt',  'card.gif',  'sub',  'sub\\3.txt']
# Рекурсивный поиск всех каталогов, начиная с текущего рабочего каталога
print(glob.glob('**/', recursive=True))        # Выведет ['sub\\']
# Рекурсивный поиск всех папок, начиная с текущего рабочего каталога, но с 
# предварительной прибавкой компонента пути ./
print(glob.glob('./**/', recursive=True))      # Выведет ['.\\', '.\\sub\\']
3)	Рассмотрим каталог, содержащий файлы: 1.gif, 2.txt, card.gif и вложенные каталоги sub который содержит файл 3.txt с папкой sub3 и sub2, который содержит файл 4.txt с папкой sub4. Подкаталоги sub3 и sub4 содержат файлы 5.txt и 6.txt соответственно. Тогда функция glob.glob() для разных шаблонов даст следующие результаты.
import glob

print(glob.glob('*.txt'))   # Выведет ['2.txt'], т.е. список всех файлов в текущем
                              рабочем каталоге согласно шаблону
print(glob.glob('*/'))      # Выведет ['sub\\', 'sub2\\'], т.е. список всех
                              каталогов в текущем рабочем каталоге
print(glob.glob('*/*.txt')) # Выведет ['sub\\3.txt', 'sub2\\4.txt'], т.е. список 
                              файлов содержащихся в папках текущего каталога 
                              согласно шаблону (как бы вывод файлов всех папок 1-го
                              уровня вложенности). Если папок в текущем каталоге
                              нет, то список будет пустым
print(glob.glob('*/*/'))    # Выведет['sub\\sub3\\', 'sub2\\sub4\\'] т.е. список
                              всех каталогов 1-го уровня вложенности
print(glob.glob('*/*/*.txt')) # Выведет ['sub\\sub3\\5.txt', 'sub2\\sub4\\6.txt']
                                т.е. список файлов папок содержащихся в папках
                                текущего каталога (т.е. список файлов подпапок)
                                согласно шаблону (как бы вывод файлов всех папок 
                                2-го уровня вложенности).
print(glob.glob('*/*/*/*.txt')) # Выведет пустой список [] т.к. папок 3-го уровня    
                                  вложенности в текущем рабочем каталоге нет.
print(glob.glob('*/*/*/*.txt', recursive=True)) # Выведет также пустой список []
                                  т.к. тут нет шаблона ** и наличие параметра
                                  recursive не имеет значения
4)	Рассмотрим каталог, содержащий файлы card.gif и .card.gif. Если каталог содержит файлы, начинающиеся с точки '.', то по умолчанию, функция glob() не включит их в возвращаемый список. Чтоб включить их в список, если такие файлы существуют, потребуется специальная обработка с использованием соответствующего шаблона, например  .[a-z]* или .с* как в примере ниже.
import glob
import os

print(glob.glob('*.gif'))  # Выведет ['card.gif']
print(glob.glob('.c*'))    # Выведет ['.card.gif']
5)	Мы можем перебирать все текстовые файлы внутри определенного каталога с помощью функции glob() и открывать их с помощью функции open(). В следующем примере кода показано, как мы можем открыть все файлы в каталоге с помощью функций glob() и open():
import glob
import os
for filename in glob.glob('files/*.txt'):
   with open(os.path.join(os.getcwd(), filename), 'r') as f:
       text = f.read()
       print(text)
В приведенном выше коде мы читаем текст из файлов внутри каталога files/ и выводим его на экран. Сначала мы используется цикл for/in с функцией glob() для перебора каждого файла, находящегося внутри каталога files. Затем мы открывали каждый файл в режиме read с помощью функции open() и печатали текст внутри каждого файла.
6)	Иногда нужно осуществить поиск всех CSV-файлов в каком-либо каталоге, например «sample_data». Это легко выполнить с помощью функции glob() или iglob() модуля glob:
from glob import glob
import os

path = os.path.join('sample_data', '*.csv')
print(list(glob(path)))
Или txt-файлов:
from glob import glob
import os

os.chdir('for test_15')

print(glob.glob(r'D:\Works of Skillbox\1. Python Basic\22\for test_15\*.txt'))
print()
path_1 = os.path.join('2', '3', '4', '*.txt')
path_2 = os.path.join('2', '3', '4', '*[0-9].txt')
path_3 = os.path.join('2', '3', '4', '[0-9]*.txt')
path_4 = os.path.join('2', '3', '4', '[a-z].txt')

for i_path in glob.iglob(path_1):
    print(os.path.abspath(i_path))
print()
for i_path in glob.iglob(path_2):
    print(os.path.abspath(i_path))
print()
for i_path in glob.iglob(path_3):
    print(os.path.abspath(i_path))
print()
for i_path in glob.iglob(path_4):
    print(os.path.abspath(i_path))

Результат выполнения кода:
['D:\\Works of Skillbox\\1. Python Basic\\22\\for test_15\\11a.txt',  'D:\\Works of Skillbox\\1. Python Basic\\22\\for test_15\\b22.txt']

D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\1.txt
D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\2a.txt
D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\3.txt
D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\6b.txt
D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\a.txt
D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\a1.txt
D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\b.txt
D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\b3.txt

D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\1.txt
D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\3.txt
D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\a1.txt
D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\b3.txt

D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\1.txt
D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\2a.txt
D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\3.txt
D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\6b.txt

D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\a.txt
D:\Works of Skillbox\1. Python Basic\22\for test_15\2\3\4\b.txt
7)	Чтобы вывести список всех подкаталогов указанного основного каталога, нужно указать /*/ в конце пути к каталогу (примерное было показано выше в  3)). Следующий фрагмент программы показывает, как вывести список всех подкаталогов внутри основного каталога.
import os
from glob import glob

os.chdir('for test_16')

for i_path in glob(os.getcwd() + "/*/"):
    print(i_path)	Результат выполнения кода:

D:\Works of Skillbox\1. Python Basic\22\for test_16\hidden\
D:\Works of Skillbox\1. Python Basic\22\for test_16\some folder\
D:\Works of Skillbox\1. Python Basic\22\for test_16\sub\
D:\Works of Skillbox\1. Python Basic\22\for test_16\test\
В приведенном выше коде мы перечислили все подкаталоги нашего текущего рабочего каталога. Недостатком этого метода является то, что он не отображает каталоги, имя которых начинается с точки.
Примеры практического применения конструкции glob.glob()
Общие примеры использования.
В приведенных ниже примерах предполагается, что в текущем рабочем каталоге содержатся папка some folder, содержащая файлы: file.txt, file1.txt, file2.txt, filea.txt, fileb.txt, file?.txt, file*.txt и папка subdir, содержащая файлы file3.txt, file4.txt.
1)	Звездочка '*' соответствует нулю или более символов в имени (или сегменте имени) файла или папки (если они присутствуют в текущей папке). Другими словами, символу звездочка '*' соответствует любое количество символов в сегменте имени, в том числе ни одного, например, some folder/*. Этому шаблону соответствует имя любого пути (к файлу или каталогу) в каталоге some folder, причем рекурсивный просмотр подкаталогов не выполняется т.к. шаблон ** отсутствует и параметр recursive не задан (а значит по умолчанию его значение False). Данные, возвращенные методом glob(), не сортируются, поэтому при необходимости их нужно дополнительно сортировать, чтобы упростить чтение результатов.
import glob
for name in glob.glob("some folder/*"):
    print(name)
# dir
# dir/file.txt
# dir/file1.txt
# dir/file2.txt
# dir/filea.txt
# dir/fileb.txt
# dir/file?.txt
# dir/file*.txt
# dir/subdir
2)	Чтобы получить список файлов, находящихся в определенном подкаталоге, можно включить имя этого подкаталога в шаблон. В примере ниже в первом случае имя подкаталога указано явно, во втором — c помощью группового метасимвола (/*/).
import glob
print(glob.glob('some folder/subdir/*'))
# ['some folder/subdir/file3.txt', 'some folder/subdir/file4.txt']
print(sorted(glob.glob('some folder/*/*'))
# ['some folder/subdir/file3.txt', 'some folder/subdir/file4.txt']
3)	При наличии еще одного непустого подкаталога (т.к. если подкаталог пуст, то и в список нечего включено не будет), например subdir_2 содержащего файл 8.txt, результирующий список включал бы имена файлов, содержащихся в обоих подкаталогах.
import glob
print(sorted(glob.glob('some folder/*/*'))
# ['some folder/subdir/file3.txt', 'some folder/subdir/file4.txt', 'some folder\\subdir_2\\8.txt']
4)	Знак вопроса '?' - это один символ подстановки. Что соответствует любому отдельному символу в этой позиции в имени. В примере ниже шаблон 'dir/file?.txt' соответствует всем именам файлов, которые начинаются с file, имеют еще один символ любого типа, а затем заканчиваются на .txt.
import glob

for name in sorted(glob.glob('dir/file?.txt')):
    print(name)
	Результат выполнения кода:
# dir/file1.txt
# dir/file2.txt
# dir/filea.txt
# dir/fileb.txt
# dir/file?.txt
# dir/file*.txt
5)	Используйте диапазон символов [a-z] или [0-9] вместо знака вопроса, чтобы соответствовать одному из нескольких символов. Пример ниже находит все файлы с цифрой в имени перед расширением.
import glob

for name in sorted(glob.glob('dir/*[0-9].*')):
    print(name)

# dir/file1.txt
# dir/file2.txt
6)	Рекурсивный поиск файлов, шаблон **
Двойной символ звездочки ** в сочетании с аргументом recursive=True разрешает поиск файлов по шаблону во всех подкаталогах указанного пути файловой системы.
import glob

for name in sorted(glob.glob('dir/**/*[0-9].txt', recursive=True)):
    print(name)

# dir/file1.txt
# dir/file2.txt
# dir/subdir/file3.txt
# dir/subdir/file4.txt
7)	Поиск файлов по шаблону и сортировкой по дате
Алгоритм будет следующий:
1.	Ищем файлы по шаблону с помощью функции glob.glob() как показано выше.
2.	В результате поиска получаем список найденных файлов.
3.	Полученный список сортируем методом list.sort(key=None).
4.	В качестве ключа key указываем функцию извлечения даты файла os.path.getmtime() (см. описание выше).
5.	Используем отсортированный по дате список файлов по назначению.
import glob
import os

# Ищем файлы по шаблону
files = glob.glob("*cycle*.log")

# Полученный список файлов сортируем используя в качестве ключа функцию 
# получения даты файла os.path.getmtime()
files.sort(key=os.path.getmtime)

# Используем отсортированный по дате список файлов по назначению
print("\n".join(files))
Также доступны функции, возвращающие следующие значения: 
os.path.getatime() — время последнего доступа к файлу, 
os.path.getmtime() — время последнего изменения файла, 
os.path.getctime() — время создания файла,
os.path.getsize () — размер файла в байтах.
Модуль pathlib
Проблема модуля os
Модуль os обрабатывает пути неестественным образом и рассмотреть альтернативу в виде модуля pathlib следует по следующим причинам:
•	os — большой модуль. В нем, конечно, есть подмодуль path для управления путями и их объединения. Однако, если нужно выполнить системные операции с этими путями (создать папку, перечислить содержимое внутри нее или переименовать и удалить файл), то приходится использовать другие методы, которые либо присутствуют где-то еще в иерархии пакетов (os.makedirs, os.listdir, os.rename и т. д.), либо импортированы из других модулей, таких как shutil или glob.
•	os представляет пути в их самом грубом формате - строковых значениях. Это сильно ограничивает возможности, так как не дает прямого доступа к такой информации, как свойства файла и его метаданные, и не позволяет выполнять операции с файловой системой путем вызова некоторых специальных методов. Например, чтобы проверить, существует ли путь, вы должны выполнить os.path.exists(some_path), когда проще получить доступ к этой информации непосредственно из объекта path через метод или атрибут класса.
•	Модуль os не позволяет находить пути, соответствующие заданному шаблону, внутри иерархии. Допустим, нужно рекурсивно найти все файлы __init__.py внутри сложной структуры папок. Чтобы сделать это, придется использовать два модуля os с glob.
•	Синтаксис os немного громоздкий и в итоге код выглядит не слишком изящно. Мы передаём строки в функции, которые возвращают строки, которые мы передаём следующим функциям, работающим со строками. Так уж случилось, что они все содержат пути, но они всё еще всего лишь строки. Использование строк для ввода и вывода в функциях os.path весьма неудобное, потому что код приходится читать изнутри наружу. Хотелось бы преобразовать эти вызовы из вложенных в последовательные. Именно это и позволяет сделать модуль pathlib.
Следовательно, модуль pathlib упрощает работу с файлами и папками. Он доступен начиная с Python 3.4. Модуль pathlib сочетает в себе лучшее из модулей файловой системы Python — os, os.path, glob и так далее.
Но для лучшего понимания работы этого модуля нужны знания ООП (потому что будут встречаться много незнакомых терминов связанных с ООП), а. т.к. мы их еще не получили, то тут изложим кратко возможности модуля pathlib чисто для ознакомления, а если он потребуется в дальнейшей работе, придется изучить его работу подробнее вместе с гуглом, но уже только после изучения ООП.
Концепт пути и директории в Python
Перед началом подробного рассмотрения модуля pathlib важно разобраться в разнице между главными концептами темы — путем (path) и директорией (directory).
•	Путь используется для идентификации файла. Путь предоставляет необязательную последовательность названий директорий, в конце которой значится конечное имя файла, а также его расширение;
•	Расширение названия файла предоставляет некоторую информацию о формате/содержимом файла. Модуль pathlib может работать как с абсолютными, так и с относительными путями;
•	Абсолютный путь начинается с корневой директории и определяет полное дерево каталогов;
•	Относительный путь, как следует из названия, является путем к файлу относительно другого файла или директории, обычно текущей. Т.е. относительный путь, например ocean/wave.txt, может относиться к нескольким местам нашей файловой системы. Например, он может быть в /Users/user_1/ocean/wave.txt или в /Users/user_2/ ocean/research/wave.txt;
•	Директория представляет собой запись пути в файловой системе и включает название файла, время создания, размер, владельца и так далее.
Справка: в Python предусмотрена возможность импорта всех функций, переменных и модулей за раз. Это плохая практика, т.к. такой импорт может засорить ваше пространство имен. Его рекомендуется использовать без ущерба лишь в примерах. Пространство имен – это место, в котором находятся все ваши переменные, пока работает программа. Для импорта всего, кроме определенных частей модуля, используется знак «*»: from math import *, но вместо этого можно использовать: import pathlib. В таком случае, классы внутри модуля, нужно будет добавлять через pathlib.
Файлы на компьютере можно идентифицировать с помощью иерархических путей. Например, мы можем идентифицировать файл wave.txt на компьютере по этому пути: /Users/planetearth/ocean/wave.txt. Но разные ОС представляют пути немного по-разному. Windows может представлять путь к файлу wave.txt так: C:\Users\planetearth\ocean\wave.txt.
Создание класса Path
Модуль pathlib предоставляет несколько классов (так называемые “чистые” (pure) классы и “конкретные” (concrete) классы), но одним из наиболее важных является класс Path т. к. он создает конкретный путь для платформы, на которой выполняется код. Экземпляры класса Path отображают путь к файлу или каталогу в файловой системе компьютера.
Если в аргументы Path ничего не передать (т.е. скобки оставить пустыми), то предполагается текущий каталог:
from pathlib import Path

>>> Path()
WindowsPath ('.')
Следующий код создает экземпляр Path, представляющий часть пути к файлу wave.txt:
from pathlib import Path

wave = Path("ocean", "wave.txt")
print(wave) #=> ocean/wave.txt
Path (“ocean”, “wave.txt”) создает новый экземпляр Path. Из результата, что Python добавил соответствующий разделитель ОС (/) между двумя компонентами пути, которые мы ему задали: «ocean» и «wave.txt». В зависимости от ОС результат может отличаться, например, если вы работаете в Windows, вы получите ocean\wave.txt (слэш левый). Т.О. объект Path, присвоенный переменной wave, содержит относительный путь.
Нюанс: чтобы создать новый путь сначала нужно передать классу Path строку, указывающую на путь в файловой системе (см. строку 2), который не обязательно должен существовать. И уже только потом можно будет расширять путь (см. строку 4), используя оператор /.  Операндом этого оператора может быть строка или другой объект пути.
1. import pathlib
2. usr = pathlib.Path('/ocean')
3. print(usr)                     #=> \ocean
4. usr_local = usr / 'shark'
5. print(usr_local)               #=> \ocean\shark

Определение текущего каталога и каталога пользователя. 
Для получения абсолютного пути к текущей рабочей директории и домашнему каталогу используются методы Path.cwd() и Path.home() соответственно.
Для этого, используем следующий код:
import pathlib

current_dir = pathlib.Path.cwd()
home_dir = pathlib.Path.home()

print(current_dir)
print(home_dir)	Результат выполнения кода:

D:\Works of Skillbox\1. Python Basic\22
C:\Users\BamblBi
Еще один пример:
from pathlib import Path

home = Path.home()
wave_absolute = Path(home, "ocean", "wave.txt")
print(home)          #=> /Users/planetearth
print(wave_absolute) #=> /Users/planetearth/ocean/wave.txt
Path.home() возвращает экземпляр Path с абсолютным путем к домашнему каталогу текущего пользователя. Затем мы передаем этот экземпляр Path и строки «ocean» и «wave.txt» в другой конструктор Path, чтобы создать абсолютный путь к файлу wave.txt. Выходные данные показывают, что первая строка – это домашний каталог, а вторая – это домашний каталог плюс ocean/wave.txt. Этот пример также иллюстрирует важную особенность класса Path: конструктор Path принимает как строки, так и уже существующие объекты Path.
Преобразование относительного пути к файлу или каталогу в абсолютный 
Чтобы сделать относительный путь к файлу или папке абсолютным можно использовать метод Path.resolve(). Его применение и результат выполнения аналогичен os.path.abspath(). Метод вернет новый объект пути pathlib.PurePath.
Пример 1:
from pathlib import Path

p_1 = Path()
p_2 = p.resolve()
print(p_1) # => PosixPath('.')
print(p_2) # => PosixPath('/home/antoine/pathlib')
Пример 2:
import os
from pathlib import Path

os.chdir('PATHLIB/test_5')

path_1 = os.path.join('ocean', 'wive.txt')
path_2 = os.path.abspath(path_1)
print(path_1)# => ocean\wive.txt
print(path_2)#=>D:\Works of Skillbox\1. Python Basic\22\PATHLIB\test_5\ocean\wive.txt

p_1 = Path('ocean') / 'wive.txt'  # А можно и так: p_1 = Path('ocean', 'wive.txt')
p_2 = p_1.resolve()               # Это аналог path_2 = os.path.abspath(path_1)
print(p_1) # => ocean\wive.txt
print(p_2) #=>D:\Works of Skillbox\1. Python Basic\22\PATHLIB\test_5\ocean\wive.txt
Сравнение путей на одинаковость
Синтаксис: Path.samefile(other_path)
Метод Path.samefile() везвращает True, если путь path указывает на тот же файл, что и аргумент other_path, который может быть либо объектом pathlib.Path, либо строкой. Этот метод аналогичен функции os.path.samefile() и os.path.samestat().
Если какой-либо файл не доступен по какой-либо причине, то выйдет ошибка OSError.
from pathlib import Path

p = Path('spam')
q = Path('eggs')

p.samefile(q)     # False
p.samefile('spam')# True
Доступ к атрибутам файла или каталога (получение имени или расширение файла или имени каталога)
Использовать объекты пути Path, создание которых было показано выше, можно для доступа к информации о файле. Для доступа к именам файлов и папок и суффиксам (расширениям) файлов можно использовать атрибуты объектов пути Path: name и suffix.
from pathlib import Path

wave = Path("ocean", "wave.txt")
print(wave)         #=> ocean/wave.txt
print(wave.name)    #=> wave.txt
print(wave.suffix)  #=> .txt
path = Path("ocean", "animals")
print(path.name)    #=> animals
Видно, что имя файла в конце пути – wave.txt, а суффикс этого файла – .txt.
Допустим, есть файл с двумя расширениями .tar и .gz. Их можно получить с помощью метода suffixes. Он возвращает список, элементами которого и будут расширения. 
Ниже приведен пример получения списка расширений.
import pathlib
print(pathlib.Path(r'C:\python3\file.tar.gz ').suffixes)
Результат
['.tar', '.gz ']

Замена имени файла в пути и его расширения
На основе любого существующего объекта пути можно легко создать новый путь, незначительно отличающийся от существующего и ссылающийся, например, на другой файл, находящийся в том же каталоге. Чтобы создать новый путь, отличающийся именем файла, используется метод with_name(). Чтобы создать новый путь, соответствующий тому же имени файла, но c другим расширением, используется метод with_suffix().
from pathlib import Path

wave = Path("ocean", "sea", "wave.txt")
py = wave.with_name("tides.py")
tides = py.with_suffix('.jpg')
print(wave)  #=> ocean/sea/wave.txt
print(py) #=> ocean/sea/tides.py
print(tides) #=> ocean/sea/tides.jpg
Этот код сначала создает экземпляр Path, который указывает на файл wave.txt. Затем мы вызываем метод with_name для wave, чтобы вернуть второй экземпляр Path, указывающий на новый файл tides.txt. Часть пути ocean/sea/ (что указывает на каталог) остается неизменной, и в результате остается конечный путь – ocean/sea/tides.txt.
Доступ к порождающим (родительским) объектам
В некоторых ситуациях бывает необходимо просто организовать доступ к определенным каталогам с уже заранее известным путем. Рассмотрим такой пример:
from pathlib import Path

shark = Path("ocean", "animals", "fish", "shark.txt")
print(shark)         #=> ocean/animals/fish/shark.txt
print(shark.parent)  #=> ocean/animals/fish
Атрибут parent в экземпляре Path возвращает ближайший порождающий объект данного пути. В примере выше он возвращает каталог, содержащий файл shark.txt: ocean/animals/fish.
Мы можем получить доступ к атрибуту parent несколько раз подряд, чтобы пройти вверх по дереву порождающих объектов данного файла:
from pathlib import Path

shark = Path("ocean", "animals", "fish", "shark.txt")
print(shark)               #=> ocean/animals/fish/shark.txt
print(shark.parent.parent) #=> ocean/animals
В этот раз мы прошли еще один уровень выше, обратившись к атрибуту .parent дважды. Два каталога выше файла shark.txt – это каталог ocean/animals.
Для создания путей в условиях, когда сегменты пути заранее неизвестны, используется метод joinpath(), передавая ему каждый сегмент в виде отдельного аргумента.
from pathlib import Path

root = Path('/')
subdirs = ['usr', 'local']
usr_local = root.joinpath(*subdirs)
print(usr_local)  #=>  \usr\local
# или
root = Path('')
subdirs = ['usr', 'local']
usr_local = root.joinpath(*subdirs)
print(usr_local)  #=>  usr\local
	# или
root_1 = Path('ocean')
root_2 = Path('sea')
usr_local = root_1.joinpath(root_2)
print(usr_local)  #=>  ocean\sea
# или
subdirs_1 = ['ocean', 'sea', 'shark']
root = Path(*subdirs_1)
print(root)
subdirs_2 = ('usr', 'local')
usr_local = root.joinpath(*subdirs_2)
print(usr_local)  #=>  \usr\local
Из примера видно, что синтаксис функции joinpath() аналогичен функции join() и передача компонентов пути в виде списка или кортежа в функцию joinpath() с помощью оператора (*) происходит также. 
Как и в случае оператора /, в результате вызова метода joinpath() создается новый экземпляр.
Вычисление относительных путей
Для вычисления путей относительно друг друга можно использовать метод Path.relative_to. Метод relative_to полезен, если, например, вы хотите получить часть длинного пути к файлу относительно какого либо каталога. Рассмотрим следующий код:
from pathlib import Path

shark = Path("ocean", "animals", "fish", "shark.txt")
below_ocean = shark.relative_to(Path("ocean"))
below_animals = shark.relative_to(Path("ocean", "animals"))
print(shark)          #=>  ocean/animals/fish/shark.txt
print(below_ocean)    #=>  animals/fish/shark.txt
print(below_animals)  #=>  fish/shark.txt
Метод relative_to возвращает новый объект Path относительно данного аргумента. В примере выше вычисляется путь к shark.txt относительно каталога ocean, а затем относительно каталогов ocean и animals.
Если relative_to не может вычислить ответ, потому что получил неправильный путь, он выдает ValueError.

Получение информации о файле
Подробную инфу о файле можно получить с помощью метода stat(). Он предоставляет ту же инфу, что и функция os.stat() (описание метрик (st_mode, st_ino, st_dev, st_nlink, st_uid, st_gid, st_size, st_atime, st_mtime, st_ctime) см. выше в описании функции os.stat()). 
Получение информации о пути
Во время работы с путями зачастую требуется найти родительскую директорию файла/папки или получить символические ссылки. У класса Path есть несколько удобных для этого методов, различные части пути доступны как свойства, что включают следующее:
Некоторые методы класса Path
•	drive: строка, что представляет название жесткого диска. К примеру, PureWindowsPath('c:/Program Files/CSV').drive вернет "C:";
•	parts: возвращает кортеж, что дает доступ к компонентам пути;
•	name: компонент пути без директории;
•	parent: последовательность обеспечивает доступ к логическим предкам пути;
•	stem: финальный компонент пути без суффикса;
•	suffix: расширение файла финального компонента;
•	anchor: часть пути перед директорией. / используется для создания дочерних путей и имитации поведения os.path.join;
•	joinpath: совмещает путь с предоставленными аргументами;
•	match(pattern): возвращает True/False, основываясь на совпадении пути с предоставленным шаблоном поиска.
Например, у нас есть данный путь "/home/projects/pyscripts/python/sample.md":
•	path: — возвращает PosixPath(‘/home/projects/pyscripts/python/sample.md’);
•	path.parts: — возвращает (‘/’, ‘home’, ‘projects’, ‘pyscripts’, ‘python’);
•	path.name: — возвращает ‘sample.md’;
•	path.stem: — возвращает ‘sample’;
•	path.suffix: — возвращает ‘.md’;
•	path.parent: — возвращает PosixPath(‘/home/projects/pyscripts/python’);
•	path.parent.parent: — возвращает PosixPath(‘/home/projects/pyscripts’);
•	path.match('*.md'): возвращает True;
•	PurePosixPath('/python').joinpath('edited_version'): возвращает (‘home/projects/pyscripts/python/edited_version’).


Проверка файла либо каталога на существование

Функция Path exists() возвращает True, если путь к файлу или каталогу существует, в противном случае возвращает False.
import os
from pathlib import Path

os.chdir('PATHLIB/test_5')

path = Path("ocean/animals")
print(path.exists())          # True
path = Path("ocean/tides.txt")
print(path.exists())          # True
path = Path("sea")
print(path.exists())          # False
path = Path("tides.txt")
print(path.exists())          # False


Получение файлов соответствующих шаблону
Функция glob.glob модуля glob (см. выше) используется для нахождения файлов, соответствующих шаблону.
from glob import glob
 
top_xlsx_files = glob('*.xlsx') # Все файлы с расширением .xlsx
all_xlsx_files = glob('**/*.xlsx', recursive=True)
Pathlib предоставляет свою реализацию модуля glob. Объекты Path включают метод glob и его рекурсивную версию rglob, которые можно использовать для вывода файлов. Эти методы в отличие от os.listdir() возвращают не список файлов и папок, а генератор объектов путей (см. пример ниже) к файлам любого типа, соответствующих заданному шаблону, расположенных в каталоге, указанном в пути Path, а значит, есть возможность их итерирования. А т.к. из генератора возвращаются объекты пути, то к ним (к объектам путей Path) можно применять атрибуты, такие как например name, suffix и т.д.
from pathlib import Path
 
top_xlsx_files = Path.cwd().glob('*.xlsx')
all_xlsx_files = Path.cwd().rglob('*.xlsx')
print(top_xlsx_files)
print(all_xlsx_files)
#=> <generator object Path.glob at 0x000002BCBDCDAFF0>
#=> <generator object Path.rglob at 0x000002BCBDCDAF10> 
Допустим, у нас есть каталог ocean, который содержит файлы tides.txt и wave.txt и папку animals. А в папке animals содержится каталог fish, в котором находится файл shark.txt.
Для перечисления всех файлов с расширением .txt в каталоге ocean, можно использовать такой код:
from pathlib import Path
 
for txt_path in Path("ocean").glob("*.txt"):
    print(txt_path)
#=> ocean\tides.txt
#=> ocean\wive.txt
Шаблон метода glob(*.txt) находит все файлы, имеющие расширение .txt. Поскольку пример вышеприведенного кода выполняет этот метод в каталоге ocean, он возвращает два файла: wave.txt и tides.txt.
Метод glob также можно использовать рекурсивно (т.е. вывести все файлы .txt в каталоге ocean и во всех его подкаталогах). Есть два способа сделать это. Покажем их на примерах.
Первый способ:
from pathlib import Path
 
for txt_path in Path("ocean").glob("**/*.txt"):
    print(txt_path)
#=> ocean\tides.txt
#=> ocean\wive.txt
#=> ocean\animals\fish\shark.txt
Шаблон '**' указывает на рекурсивный обход в глубину каталога, указанного в пути Path("ocean"), и всех его подкаталогов. Следует помнить, что использование шаблона '**' в больших деревьях каталогов может занять слишком много времени.
Второй способ:
from pathlib import Path
 
for txt_path in Path("ocean").rglob("*.txt"):
    print(txt_path)
#=> ocean\tides.txt
#=> ocean\wive.txt
#=> ocean\animals\fish\shark.txt
А метод Path.rglob('*.txt') работает подобно вызову метода Path.glob('**/*.txt') с добавлением конструкции '**/' перед заданным относительным шаблоном (pattern), тем самым по умолчанию производит рекурсивный поиск файлов, соответствующих указанному шаблону. Т.е. метод glob поддерживает рекурсивное сканирование c использованием префикса шаблона ** либо посредством вызова метода rglob('*.txt') вместо glob('**/*.txt').

Получение папок и файлов каталога
Метод Path.iterdir() возвращает итератор объектов пути (т.е. содержимое каталога, а это файлы и папки), если путь path указывает на каталог.
Мы можем использовать функцию Path.iterdir() для перебора файлов и папок в каталоге. 
import os
from pathlib import Path

os.chdir('PATHLIB/test_5/ocean')

path = Path()       # Создаем объект пути к текущему каталогу

subdirs = []
files = []

for x in path.iterdir():       # перебираем файлы и папки по пути path
    if x.is_dir():             # условие проверки является ли объект каталогом
        subdirs.append(str(x)) # используем ф-цию str для перобразования объекта в
                                 строку и уже ее добавим в список
    else:
        files.append(str(x))

print(subdirs) #=> ['animals']
print(files)   #=> ['tides.txt', 'wive.txt']
Для преобразования, возвращаемого из итератора объекта пути в строку, объект пути просто передается в функцию str() при добавлении пути в список. В коде мы также использовали функцию is_dir(), чтобы разграничить файлы и каталоги. 
Если путь path указывает на каталог, то выйдет ошибка: NotADirectoryError.
import os
from pathlib import Path

os.chdir('PATHLIB/test_5/ocean')

p = Path('.', 'tides.txt')
for child in p.iterdir():
    print(child)
#=> NotADirectoryError: [WinError 267] Неверно задано имя папки: 'tides.txt'
Подробнее см. https://docs-python.ru/standart-library/modul-pathlib-python/poluchit-spisok-fajlov-direktorii/.

Создание и удаление файлов и папок
Классический модуль os.path используется только для манипуляции строками пути. Чтобы что-то сделать с путем, например, создать директорию, нам нужен модуль os. Модуль os предоставляет набор функций для работы с файлами и каталогами, например: mkdir для создания директории, rename для переименования, а getsize для получения ее размера.

Удалить файлы, соответствующему какому-либо шаблону можно с помощью метода unlink, который удаляет объект пути:
from pathlib import Path

path = pathlib.Path("/home/user/images")
for p in path.glob('*.txt'):
    p.unlink()


Для закрепления материала, напишем некоторые операций с помощью модуля os, а затем перепишем тот же код с помощью модуля pathlib. Для начала, удалим папку «f_1»: 
import os

os.chdir('PATHLIB/test_3')
path = os.path.join(os.getcwd(), 'f_1')
if os.path.isdir(path):
    os.rmdir(path)
Ниже используются объекты path модуля pathlib для достижения той же цели:
import os
import pathlib

os.chdir('PATHLIB/test_3')          # Меняем рабочую директорию (в модуле pathlib
                                      нет аналога функции chdir() модуля os)
path = pathlib.Path.cwd() / 'f_1'   # Создаем путь к папке f_1
if path.is_dir():               # К пути path применяем метод is_dir модуля pathlib
    path.rmdir()                # К пути path применяем метод rmdir модуля pathlib
На примере ниже также покажем разницу в коде реализованного с помощью os и pathlib:
import os

os.chdir('PATHLIB/test_4')

outpath = os.path.join(os.getcwd(), 'output') # Создадим путь к папке output
outpath_tmp = os.path.join(os.getcwd(), 'output.tmp') # Создадим путь к файлу
                                                        output.tmp
if os.path.getsize(output_tmp):      # Если размер файла output.tmp не ноль 
                                      (ноль-False,любое число - True):
    os.rename(outpath_tmp, outpath)  # то переименовываем его с output.tmp в output
                                      (т.е. удаляем расширение)
else:
    os.remove(outpath_tmp)                       # иначе удаляем файл output.tmp
В переменной outpath соединены текущий рабочий каталог с названием файла «output». Далее создана временная версия файла outpath.tmp. Если размер временной версии файла outpath.tmp не равен нулю (а это значит, что файл не пустой), тогда временная версия переименовывается в outpath, иначе временная версия удаляется, а старая версия сохраняется.
Т.О. если файл outpath.tmp не пустой, то он переименовывается в outpath, иначе просто удаляется.
Используя модуль os, манипулирование путями файловых систем в виде строковых объектов становится несколько «корявым», поскольку используется несколько вызовов os.path.join(), os.getcwd() и так далее. Во избежание данной проблемы модуль pathlib предлагает набор классов, которые могут использоваться для популярных операций с путями через более читабельный, простой, объектно-ориентированный способ.
Перепишем вышеуказанный код, используя модуль pathlib:
from pathlib import Path
 
outpath = Path.cwd() / 'output'         # Создадим путь к папке output
outpath_tmp = Path.cwd() / 'output.tmp' # Создадим путь к файлу output.tmp
 
if outpath_tmp.stat().st_size:  # Если файл output.tmp непустой,
    outpath_tmp.rename(outpath) # то переименовываем его с output.tmp в output 
else:
    outpath_tmp.unlink()           # иначе удаляем файл output.tmp
При использовании pathlib  конструкция os.getcwd() заменяется на Path.cwd(), а оператор '/' нужен для объединения путей вместо os.path.join. Как видно, используя операторы и методы модуля pathlib можно значительно упростить код.

Некоторые методы и их предназначение (не рассмотренные тут)
•	Path.chmod(): Меняет режим и уровень доступа файла;
•	Path.mkdir(): создает новую папку по данному пути;
•	Path.open(): Открывает файл, созданный в пути;
•	Path.rename(): Переименовывает файл или директорию указанной цели;
•	Path.rmdir(): Удаляет пустую директорию;
•	Path.unlink(): Удаляет файл или символическую ссылку.
Объединение путей
Допустим, мы хотим создать файл под названием "output/sample.txt" в текущем каталоге. Код ниже делает это с помощью модуля os.path и функций os.getcwd() и os.path.join().
import os

os.chdir('PATHLIB/test_1')

outpath = os.path.join(os.getcwd(), 'output')    # Создадим путь к папке output
os.mkdir(outpath)                                # Создадим папку output
outpath_file=os.path.join(outpath, 'sample.txt') # Создадим путь к файлу sample.txt

file = open(outpath_file, 'x') # Создадим файл sample.txt
file.write('Hello World!')     # Сделаем запись
file.close()                   # Закроем файл
Альтернативный способ:
import os

os.chdir('PATHLIB/test_1')

os.mkdir(os.path.join(os.getcwd(), 'output')) # Создадим папку output
# Далее создадим файл sample.txt
file = open(os.path.join(os.path.join(os.getcwd(), 'output'), 'sample.txt'), 'w')
file.write('Hello World!')
file.close()
Хотя код работает, он выглядит несколько странно и громоздко, плохо читается, в нем сложно уловить суть. Представьте, как данный код выглядел бы, если бы мы хотели создать новый файл внутри глубоко расположенной директории. Но его можно переписать, используя модуль pathlib так:
import os
from pathlib import Path

os.chdir('PATHLIB/test_2')

if not os.path.exists(Path.cwd() / 'output'):
    os.mkdir(Path.cwd() / 'output')         # Создаем папку output если ее еще нет

with open(Path.cwd() / 'output' / 'sample.txt', 'w') as file: # Создаем файл
    file.write('Hello World!')
Такой формат проще укладывается в голове. Функция Path.cwd() используется для получения текущего рабочего каталога, а оператор / используется вместо os.path.join для объединения частей пути в составной объект пути.
Шаблон вложенности функций в модуле os.path заменяется классом Path модуля pathlib, что представляет путь через объединение методов и атрибутов.
Рассмотрим поддержку строк и объектов Path в конструкторе Path:
from pathlib import Path

shark = Path(Path.home(), "ocean", "animals", Path("fish", "shark.txt"))
print(shark) #=> /Users/planetearth/ocean/animals/fish/shark.txt
Тут shark – это путь к файлу, который мы создали, используя объекты Path (Path.home() и Path(“fish”, “shark.txt”). Конструктор Path обрабатывает оба типа объектов и аккуратно объединяет их, используя соответствующий разделитель ОС.
Генерация кроссплатформенных путей в pathlib
Пути используют разные соглашения в разных операционных системах. Windows использует обратный слеш \ между названиями папок, тогда как все другие популярные операционные системы используют прямой слеш /.
Если вы хотите, чтобы ваш код работал, независимо от базовой ОС, вам нужно будет обрабатывать различные соглашения, характерные для базовой платформы. Модуль pathlib упрощает работу с путями к файлам, т.к. в нем можно просто передать путь или название файла объекту Path, используя слеш, независимо от ОС,  а далее pathlib сделает все остальное сам.
import pathlib
p = pathlib.Path.home() / 'python' / 'samples' / 'test_me.py' 
print(p) #=> C:\Users\BamblBi\python\samples\test_me.py
Объект Path конвертирует оператор (/) в слеш соответствующий операционной системе. pathlib.Path может представлять путь Windows или Posix.














Открытие файла, чтение из файла и запись в файл
Описанные ниже методы позволяют производить открытие файла, чтение и запись в файл средствами модуля pathlib.
1)	Path.open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)
Метод Path.open() открывает файл, на который указывает путь path, как это делает встроенная функция open():
Справка
Файловый объект (ФО) file object, это объект, предоставляющий файлово-ориентированный API. Тип file object также называют файловыми объектами или потоками. ФО относится к итераторам, это значит, что можно считывать данные из файла в цикле без использования метода чтения file.read().
Функция open() – открывает файл,  в соответствующем режиме (см. ниже) и возвращает ФО для его дальнейшей обработки.
Синтаксис: <Имя ФО > = open(file, mode='r', buffering=-1, encoding=None, errors=None,
                                                           newline=None, closefd=True, opener=None)
где file - абсолютное или относительное значение пути к файлу, mode – режим работы,  
encoding - кодировка, используемая для декодирования или кодирования файла.
Есть следующие режимы (mode) открытия файлов:

• «r» - открыть файл только для чтения (значение по умолчанию);
• «r+» - открыть файл для чтения и записи;
• «w» - открыть файл для записи (если файл существует, то его содержимое удаляется, иначе создается новый);
• «w+» - открыть файл для чтения и записи (если файл существует, то его содержимое удаляется, иначе создается новый);
• «a» - открыть файл для добавления записи (дозаписи). Данные добавляются в конец файла;
• «a+» - открыть файл для чтения и записи. Данные добавляются в конец файла;
• «x» - открыть файл для записи, если файла не существует. Если указано имя существующего файла, то будет выброшено исключение (т.е. будет брошено исключение FileExistsError, если файл уже существует);
• «x+» - в режиме x+ файл открывается как для чтения, так и для записи.
Примечание: если в режимах работы «w» и «а», файла не существовало к моменту его открытия, то Python сам создаст его с указанным в пути (это первый аргумент) именем.
Подробнее см: https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-open/
ФО имеет методы и атрибуты, которые можно использовать для чтения/записи данных, а так-же для управления файлом, который был открыт:
Список атрибутов, связанных с ФО:
•	file.closed: Возвращает True, если файл закрыт, иначе False;
•	file.mode: Возвращает режим доступа, с которым файл был открыт;
•	file.name: Возвращает путь до файла с именем файла.
Список методов, связанных с ФО:
•	file.read([size]): считывает из файла не более size байтов. Если достигается конец файла EOF до получения указанного размера size байтов, тогда метод считает только доступные байты.
•	file.readline([size]): читает одну целую строку из файла. Конечный символ новой строки \n сохраняется в строке.
•	file.readlines([sizehint]): читает файловый объект построчно, пока не достигнет конца файла EOF, и возвращает список, содержащий строки файла. Если присутствует необязательный аргумент sizehint, то читаются целые строки, составляющие приблизительно sizehint байт (округляется до внутреннего размера буфера).
•	file.write(str): записывает строку str в файл file. Метод возвращает целое число - количество записанных байт.
•	file.writelines(sequence): записывает последовательность строк в файл file. Последовательностью может быть любой итерируемый объект, содержащий в качестве элементов строки. Обычно это список строк. Метод не добавляет разделители строк автоматически. Если они требуются, то добавляйте их вручную.
•	file.seek(offset): устанавливает текущую позицию offset указателя для чтения/записи в файле file.
•	file.tell(): возвращает текущую позицию указателя чтения/записи в файле в байтах.
•	file.close(): закрывает открытый файл. Закрытый файл больше не может быть прочитан или записан. Любая операция, которая требует, чтобы файл был открыт, вызовет исключение ValueError после того, как файл был закрыт.
Другие методы см: https://docs-python.ru/tutorial/metody-fajlovogo-obekta-potoka-python/.

Т.е. мы можем использовать функцию Path.open(), чтобы открыть файл. Она возвращает файловый объект, такой как встроенная функция open().
import os
from pathlib import Path

os.chdir('PATHLIB/test_5')

file_path = Path("text.txt")
if file_path.exists() and file_path.is_file():
    with file_path.open(encoding='utf-8') as f:
        print(f.readlines())#=>['Тут какой то текст...\n', 'И привет Всем!']
2)	Path.write_text(data, encoding=None, errors=None, newline=None)
3)	Path.read_text(encoding=None, errors=None)
Метод Path.write_text() открывает файл для записи в текстовом режиме, записывает в него данные data и закрывает его. В результате работы возвращает количество символов (длину текста).
Метод Path.read_text() возвращает декодированное содержимое указанного в пути Path файла в виде строки. В результате работы метода, файл открывается, а затем закрывается.
Пример использования методов Path.write_text() и Path.read_text():
import os
from pathlib import Path

os.chdir('PATHLIB/test_5')

p = Path('my_text_file.txt')
data = 'Тут можно написать любые текстовые данные'
print(len(data))            # => 41
print(p.write_text(data))   # => 41
print(p.read_text())        # => Тут можно написать любые текстовые данные
Если файла 'my_text_file' не существует, он будет создан, а иначе будет перезаписан. Необязательные параметры имеют то же значение, что и встроенная функция open().
Метод Path.read_text() можно использовать только для чтения содержимого файла:
import os
from pathlib import Path

os.chdir('PATHLIB/test_5')

path = Path.cwd() / 'text.txt'
print(path.read_text(encoding='utf-8'))
# => Тут какой то текст...
# => И привет Всем!
Метод Path.write_text() также можно использовать только для записи данных в файл:
import os
from pathlib import Path

os.chdir('PATHLIB/test_5')
 
p = Path('text_2.txt')
p.write_text('Образец данных для записи в файл')
4)	Path.read_bytes()
5)	Path.write_bytes(data)
Метод Path.read_bytes() вернет двоичное содержимое указанного файла в виде байтового объекта. В результате работы метода, файл открывается, а затем закрывается.
Метод Path.write_bytes() открывает файл в байтовом режиме для записи, записывает в него данные data и закрывает его.
>>> from pathlib import Path
>>> p = Path('my_binary_file')
>>> p.write_bytes(b'Binary file contents')
# 20
>>> p.read_bytes()
# b'Binary file contents'
Если файла не существует, он будет создан, а иначе будет перезаписан.
Подробнее см.: https://docs-python.ru/standart-library/modul-pathlib-python/otkrytie-fajla-chtenie-zapis-informatsii/.
Модуль pathlib VS модулям os и os.path
Ниже приведена таблица, в которой различные функции модулей os и os.path сопоставлены с соответствующими эквивалентами pathlib.PurePath/pathlib.Path.
Грубо говоря этот материал сравнивает инструменты pathlib с функциями/методами модулей os и os.path.
Примечание. Не все пары функций/методов ниже эквивалентны. Некоторые из них, несмотря на некоторые частично совпадающие варианты использования, имеют разную семантику. К ним относятся os.path.abspath() и Path.resolve(), os.path.relpath() и Path.relative_to().
Функция os.path.abspath() не разрешает символические ссылки, в то время как Path.resolve() это делает.
Метод Path.relative_to() требует, чтобы путь Path был подпутем аргумента, но os.path.relpath() этого не требует.
Функции модулей os и os.path	Функции модуля pathlib
os.path.abspath()	Path.resolve()
os.chmod()	Path.chmod()
os.mkdir()	Path.mkdir()
os.makedirs()	Path.mkdir()
os.rename()	Path.rename()
os.replace()	Path.replace()
os.rmdir()	Path.rmdir()
os.remove(), os.unlink()	Path.unlink()
os.getcwd()	Path.cwd()
os.path.exists()	Path.exists()
os.path.expanduser()	Path.expanduser() и Path.home()
os.listdir()	Path.iterdir()
os.path.isdir()	Path.is_dir()
os.path.isfile()	Path.is_file()
os.path.islink()	Path.is_symlink()
os.link()	Path.hardlink_to()
os.symlink()	Path.symlink_to()
os.readlink()	Path.readlink()
os.path.relpath()	Path.relative_to()
os.stat()	Path.stat(), Path.owner(), Path.group()
os.path.isabs()	PurePath.is_absolute()
os.path.join()	PurePath.joinpath()
os.path.basename()	PurePath.name
os.path.dirname()	PurePath.parent
os.path.samefile()	Path.samefile()
os.path.splitext()	PurePath.suffix

Чего не хватает в pathlib?
Хотя pathlib и классная, но не всеобъемлющая. Определённо есть несколько возможностей, которые нужно было включить в модуль.
Первое, это недостаток методов у Path, эквивалентных shutil. И хотя можно передавать Path как параметры shutil для копирования/удаления/перемещения файлов и директорий, вызывать их как методы у объектов Path не получится.
Так что, для копирования файлов, необходимо сделать что-то вроде этого:
from pathlib import Path
from shutil import copyfile

source = Path('old_file.txt')
destination = Path('new_file.txt')
copyfile(source, destination)
Также нет аналога метода os.chdir. Это означает, что вам необходимо её импортировать, если возникнет необходимость сменить текущую директорию:
from pathlib import Path
from os import chdir

parent = Path('..')
chdir(parent)
Также нет эквивалента функции os.walk. Хотя вы можете написать свою собственную функцию в духе walk без особых сложностей.
Возможно однажды объекты pathlib.Path будут содержать методы для некоторых из упомянутых операций. Но даже при имеющемся раскладе гораздо удобнее использовать pathlib с чем-то еще, чем использовать os.path и всё остальное.
Скорость работы модуля pathlib по сравнению с os.path
Это правда, скорость работы модуля os.path значительно выше по сравнению с pathlib. Модуль pathlib работает примерно в 2 раза медленнее. Создание множества объектов Path (в зависимости от количества обрабатываемых данных)  заметно сказывается на поведении программы. Но если скорость работы кода не важно, то pathlib отлично заменит модуль os.path.


Модуль zipfile
Модуль zipfile в настоящее время не обрабатывает многотомные zip-архивы (архивы данных, состоящие из нескольких частей - томов) и архивы c присоединенными комментариями. Но он поддерживает zip-архивы размером свыше 4 Гб, использующие расширения ZIP64. 
Модуль zipfile поддерживает дешифрование зашифрованных файлов в zip-архивах (т.е. распаковку запароленных zip-архивов), но в настоящее время не может создать зашифрованный файл (т.е. запароленный zip-архив). Расшифровка хоть и есть, но она очень медленная, так как она реализована на родном Python, а не на языке C. 
Подробнее: https://docs-python.ru/standart-library/modul-zipfile-python/.
Архивирование и разархивирование файлов
При работе с файлами может потребоваться их архивирование и разархивирование. Такие возможности предоставляет модуль zipfile.
Как функция open() открывает файл для чтения или записи и возвращает файловый объект, имеющий свои методы и атрибуты, так и функция ZipFile() модуля zipfile открывает zip-файл (т.е. zip-архив) для его чтения, добавления или записи в него файла/ов и возвращает объект  ZipFile, который также имеет свои методы и атрибуты. Возвращаемый объект можно присвоить любой переменной, которая после этого будет являться объектом ZipFile, и к ней можно будет применять соответствующие этому объекту методы и атрибуты.
Т.О. функция ZipFile() модуля zipfile открывает zip-файл (т.е. zip-архив) для чтения, добавления или записи в него файла/ов и создает объект ZipFile для его дальнейшей обработки.
Синтаксис функции ZipFile() модуля zipfile: 
<Имя объекта ZipFile> = zipfile.ZipFile(file, mode='r', compression=ZIP_STORED, 
                                                                allowZip64=True, compresslevel=None, *, 
                                                        strict_timestamps=True)
где file – может быть абсолютным или относительным значением пути к zip-архиву (строка), объектом Path модуля pathlib, или файловым объектом;  
mode – режим работы:
Есть следующие режимы (mode):

• «r» - для чтения существующего архива (значение по умолчанию);
• «w» - для записи файла/ов в новый архив (если архив уже существует, то его содержимое при каждом запуске кода будет перезаписываться, а иначе будет создаваться новый архив);
• «a» - для добавления файла/ов к уже существующему архиву (если архива не существует, будет создан новый);
• «x» - исключительно для записи файла/ов в новый архива, при условии, что его еще не существует, иначе будет вызвана ошибка FileExistsError.
compression - это метод сжатия zip-архива, который может принимать следующие значения:
•	zipfile.ZIP_STORED: Числовая константа для добавления файлов в архив без сжатия.
•	zipfile.ZIP_DEFLATED: Числовая константа для обычного метода сжатия ZIP.
•	zipfile.ZIP_BZIP2: Числовая константа для метода сжатия BZIP2.
•	zipfile.ZIP_LZMA: Числовая константа для метода сжатия LZMA.
compresslevel управляет уровнем сжатия, используемым при записи файлов в архив. Для zlib.ZIP_DEFLATED принимаются целые числа от 0 до 9:
•	0 - не производит сжатия;
•	1 - является самым быстрым и производит наименьшее сжатие;
•	9 - является самым медленным и производит максимальное сжатие.
Для использования zipfile.ZIP_DEFLATED нужен модуль zlib, для zipfile.ZIP_BZIP2 модуль bz2, а для zipfile.ZIP_LZMA модуль lzma. Ели соответствующий недоступен (не установлен), возникнет исключение RuntimeError. По умолчанию используется zipfile.ZIP_STORED.
Проверка файла на zip-архив
Функция is_zipfile(filename) модуля zipfile возвращает True, если имя проверяемого файла filename является действительным zip-архивом на основе его магического номера, в противном случае возвращает False.
>>> import zipfile
>>> zipfile.is_zipfile('test.zip') # True
>>> zipfile.is_zipfile('test.py')  # False

Извлечение всего содержимого (всех файлов и папок) из zip-архива
Для извлечения всех файлов и папок из zip-архива можно использовать метод ZipFile.extractall(path=None, members=None, pwd=None), который по умолчанию извлекает все элементы zip-архива в текущий рабочий каталог. С помощью аргумента path можно указать путь к другому каталогу для извлечения архива, причем если он уже существует, файлы будут в него распакованы без всяких ошибок, а если такого каталога еще нет, то перед распаковкой в него файлов, он будет создан. Аргумент pwd – пароль (указывается в виде байтовой строки, например: pwd=b'123'), используемый для извлечения запароленных архивов. Я попробовал распаковать запароленный в WinRar zip-архив, с указанием пароля для распаковки согласно синтаксису этой функции, но так и не смог добиться успешной распаковки. 
import os, zipfile, glob

os.chdir('PATHLIB/test_6/extract from archive')

extract_dir = 'extract_dir'

zf = zipfile.ZipFile('files.zip')
zf.extractall(extract_dir)
zf.close()

for file in glob.glob(extract_dir + '/**', recursive=True):
    print(file)	Результат:

extract_dir\
extract_dir\1
extract_dir\1\2
extract_dir\1\2\4.txt
extract_dir\1\2\5.txt
extract_dir\1\2\6.txt
extract_dir\1.txt
extract_dir\2.txt
extract_dir\3.txt
Метод ZipFile.close() закрывает файл архива. Необходимо вызвать этот метод перед выходом из программы, иначе не вся информация будет записана.

Использование контекстного менеджера
Объект ZipFile является контекстным менеджером и поэтому поддерживает оператор with. В примере ниже, ZipFile-объект myzip закроется после завершения набора инструкций with, даже если возникает исключение:
import os, zipfile

os.chdir('PATHLIB/test_6/extract from archive')

zip_file = zipfile.ZipFile('files.zip', 'r')
zip_file.extractall()      # Извлеч в текущий раб. каталог
zip_file.close()

# Эквивалентно

with zipfile.ZipFile('files.zip') as zip_file:
    zip_file.extractall()  # Извлеч в текущий раб. каталог
Извлечение единичных файлов
Метод ZipFile.extract(member, path=None, pwd=None) извлекает элемент архива member в текущий рабочий каталог аналогично ZipFile.extractall().
Отличие ZipFile.extract () от ZipFile.extractall() состоит лишь в том, что необходимо сначала подставить имя файла member, а затем, путь path к другому каталогу для извлечения архива. Вот пример кода для извлечения отдельных файлов.
import os, zipfile

os.chdir('PATHLIB/test_6/extract from archive')

with zipfile.ZipFile('files.zip') as zip_file:
    zip_file.extract('1/2/4.txt', 'extract_dir_2') # '1/2/4.txt' относительный путь
                                                      до файла внутри архива
    zip_file.extract('1.txt', 'extract_dir_2')

Получение списка всех элементов zip-архива
Метод ZipFile.namelist() возвращает список членов архива по имени без его распаковки. Однако список членов - это всего лишь часть информации, которую можно получить из архива. Для доступа к метаданным элементов zip-архива, используются методы infolist() и getinfo().
import os, zipfile

os.chdir('PATHLIB/test_6/extract from archive')

with zipfile.ZipFile('files.zip') as zf:
    print(zf.namelist())         # = > ['3.txt',  '1/',  '1/2/',  '1/2/4.txt',  '1/2/5.txt',  '1/2/6.txt',  '1.txt',  '2.txt']
    for name in zf.namelist():
        print(name)

Получение оглавления архива
Метод ZipFile.printdir() печатает оглавление архива.
import os, zipfile

os.chdir('PATHLIB/test_6/extract from archive')

with zipfile.ZipFile('files.zip') as zf:
    zf.printdir()

File Name                                             Modified             Size
3.txt                                          2022-05-13 20:31:10            0
1/                                             2022-05-14 10:29:22            0
1/2/                                           2022-05-14 10:29:36            0
1/2/4.txt                                      2022-05-14 10:29:26            0
1/2/5.txt                                      2022-05-14 10:29:32            0
1/2/6.txt                                      2022-05-14 10:29:36            0
1.txt                                          2022-05-13 20:30:56            0
2.txt                                          2022-05-13 20:31:06            0


Получение данных из файла без его извлечения из архива
Для доступа к данным, содержащимся в элементе архива, используется метод ZipFile.read(name, pwd=None), которому передается имя элемента name. Архив при этом должен быть открыт для чтения или добавления (mode=’r’ или ‘a’ соответственно). Метод ZipFile.read() возвращает байты прочитанный из файла в архиве с именем name.
import os, zipfile

os.chdir('PATHLIB/test_6/extract from archive')

with zipfile.ZipFile('files.zip') as zf:
    byte_text = zf.read('1.txt')
    text = zf.read('2.txt')
    print(byte_text.decode('utf-8')) # => b'\xd0\x9f\x.. .. \xbc!'
    print(byte_text.decode('utf-8')) # => Привет всем питонщикам!
    print(text)                      # => b'Hello world!'
    print(text.decode('utf-8'))      # => Hello world!
Для кодирования и декодирования текста существуют методы str.encode() и bytes.decode().
Метод decode() (синтаксис: bytes.decode(encoding='utf-8', errors='strict')) возвращает строку, декодированную из заданных байтов. Кодировка encoding по умолчанию - "utf-8".


Запаковака (сжатие) файлов в архив
Для создания нового архива, нужно создать экземпляр ZipFile в режиме 'w'. Если файл c таким именем уже существует, то его содержимое усекается (перезаписывается) и архив создается заново. Для добавления в этот новый архив файлов используется метод write().

архива 


Добавление файлов в архив





Полный список атрибутов и методов, связанных с объектом  ZipFile см тут: 
https://docs-python.ru/standart-library/modul-zipfile-python/obekt-zipfile-modulja-zipfile/ .
Примеры использования: 
Если с помощью конструкции zipfile.ZipFile() в режиме w, x или a был создан объект ZipFile, а затем был закрыт без добавления в него каких-либо файлов (т.е. в архив), то создается просто пустой файл zip-архива. Причем если такой архив уже существовал, он презапишется на пустой. Например:
import os, zipfile

os.chdir('PATHLIB')

zip_file = zipfile.ZipFile('test_6/extract from archive/files.zip', 'w')
zip_file.close()





Обратимся к фрагменту кода с простым примером:
import os
from pathlib import Path
from zipfile import ZipFile

os.chdir('PATHLIB/test_6')

# Создание zip-файла, содержащего все текстовые файлы в директории
with ZipFile('arhive/text_files.zip', 'w') as file:
    for txt_file in Path('arhive').glob('*.txt'):
        print(f"* Файл: {txt_file.name} добавлен в zip-архив")
        file.write(txt_file)

# * Файл: 1.txt добавлен в zip-архив
# * Файл: 2.txt добавлен в zip-архив 
# * Файл: 3.txt добавлен в zip-архив

Вы можете получить zip-файл из внешнего источника, и вам потребуется извлечь из него файлы. Допустим, что мы распаковываем их в текущую директорию. 
Если имена извлекаемых из zip-архива файлов совпадают с именами файлов уже содержащихся в директории, то последние будут перезаписаны без предупреждения. Поэтому лучше использовать вариант извлечения содержимого zip-архива в отдельную папку, тогда такой проблемы перезаписи не возникнет.

from pathlib import Path
from os import chdir





Подробнее: https://docs-python.ru/standart-library/modul-zipfile-python/klass-zipfile-modulja-zipfile/. 





А как в python создать rar архив?
Есть способ, не привязанный к ОС и работающий в виртуальном окружении
# pip install patool
import patoollib

patoolib.create_archive('test.rar', ("file_to_rar",))
Приведем еще один пример создания архива через модуль patoolib. В архиве будет только содержимое папки:
import os

# pip install patool
import patoolib


DIR = "<папку, чье содержимое нужно отправить в архив>"

# Запоминаем текущую активную директорию
prev_cwd = os.getcwd()

# Меняем активную директорию на папку DIR
os.chdir(DIR)

# Получаем содержимое папки DIR
files = os.listdir('.')

# Создаем архив, указывая путь в папку выше с списком файлов DIR
patoolib.create_archive('../' + DIR + '.rar', files)

# Восстанавливаем предыдущую активную директорию
os.chdir(prev_cwd)




Остальные способы сжатия и архивирования файлов доступные в Python
См. тут: https://docs-python.ru/tutorial/szhatija-arhivirovanija-fajlov-python/.



Заключение
Модуль pathlib предоставляет огромное количество полезных функций, которые можно использовать для выполнения различных операций, связанных с путями (и тут рассмотрены и приведены далеко не все возможности этого модуля). В качестве дополнительного преимущества библиотека согласовывается с операционной системой.
Более подробную инфу по pathlib можно получить в справочнике: «Стандартная библиотека Python» стр. 329-342. А так же в статье «Почему вам следует использовать pathlib _ Хабр» находящейся по пути: D:\КУРСЫ\skladchik.com\[SkillBox] Профессия Python-разработчик\
1 Python Basic (готов)\22.Работа с файлами\Допы\Работа с файлами. Но следует отметить, что без знаний ООП  эти материалы понять будет, мягко говоря, очень не просто.













Директория со скриптом
Текущая рабочая директория может отличаться от директории с текущим Python-скриптом. 
Чтобы получить директорию с текущим Python скриптом можно использовать такой код:
Код 1:
os.path.dirname(os.path.abspath(__file__)
Специальная переменная __file__ - это путь к файлу, из которого запущен скрипт.
Если не использовать конструкцию os.path.abspath в коде 1, то при обращении (т.е. при использовании кода 1) из разных каталогов, результат выполнения кода os.path.dirname(__file__) может принимать разные значения и не всегда может содержать абсолютный путь к файлу.
Использование переменной __file__ в сочетании с различными методами 
os и os.path позволяет использовать все пути в вашем коде относительно директории с текущим Python-скриптом. Т.е. позволяет все пути вашего кода соотнести с местоположением каталога текущего скрипта. А это, в свою очередь позволяет переносить ваши скрипты/модули/проекты на другие компьютеры и директории без всяких проблем, с сохранением их работоспособности.
Начиная с Python v. 3.4, переменная __file__ содержит абсолютный путь всегда кроме одного случая: когда скрипт вызван напрямую (__name__ == '__main__'). Т.е. если есть файл с таким содержимым
def f():
    print(__file__)

if __name__ == '__main__':
    f()
то при его запуске скрипт выведет лишь имя файла, т.е. относительный путь. Если же функцию f откуда-то импортировать, то переменная __file__, выводимая в функции f, будет содержать уже абсолютный путь. Именно во избежание подобного рода путаницы и используется конструкция os.path.abspath в коде 1.
Если нужно получить путь к текущему выполняемому скрипту, то можно прочитать значение из специальной переменной __file__ (она не определена в REPL, только в скриптах, которые запускаются из файлов).
Абсолютный путь к выполняемому скрипту можно получить еще и так:
from pathlib import Path

file = Path(__file__)

print(file.absolute())
Если нужно получить имя главного модуля программы, то можно __file__ заменить на __main__.__file__.
Как скомпилировать python-скрипт в исполняемый файл (exe-файл)
Для этого существует не одним модуль. Просты в использовании модули pyinstaller и 
auto-py-to-exe. Подробные материалы для создания exe-файла из кода Python, приведены в материалах в папке: D:\КУРСЫ\skladchik.com\[SkillBox] Профессия Python-разработчик\1 Python Basic (готов)\22.Работа с файлами\Допы\Создание exe файла из Python кода.











Распространенные форматы текстовых данных (кратко)
CSV
csv является табличным форматом. В нем содержатся значения разделенные запятой (Comma-Separated Values). Например,
first name,last name,module1,module2,module3
Nikolay,Neznaev,0,20,10
Stepan,Sharyashiy,100,99.5,100
Для работы с csv файлами можно воспользоваться библиотекой csv. Для получения подробностей нужно «гуглить».
JSON
JSON (JavaScript Object Notation) - простой формат обмена данными, удобный для чтения и написания как человеком, так и компьютером. Впервые он был придуман и использован в JavaScript для хранения структур и классов, но быстро обрел свою популярность и вышел за пределы своего родителя.
Объекты в формате JSON хранятся как словари в Python, но с некоторыми деталями:
•	во первых, ключом в json-объекте может быть только строка;
•	значения True и False пишутся с маленькой буквы;
•	значению None соответствует значение null;
•	строки хранятся только внутри двойных кавычек.
Для удобной работы с json файлами в языке python можно использовать библиотеку json. Для получения подробностей нужно «гуглить».
